---
title: 动态代理
date: 2020-08-03 01:28:07
tags: 动态代理
categories: spring源码阅读
---

从今天开始，要看spring源码了。不是突发奇想，而是很早就有的计划了，不然写代码不知道数据是怎么来的就很烦。。。。。。好了话不多说，最近几天先看一下spring源码的预备知识。

<!-- more -->

嗯，怎么说呢，不知道从何说起，就直接上代码吧，慢慢来，后面从网上弄一张代理模式的类图。

动态代理需要一个接口。jdk的动态代理以接口实现的。这点与cglib不同，今天主要记录一下jdk代理的学习。

这是一个AFactory的接口
```java
public interface AFactory {
    void say();
}
```

一个AFactory的实现类
```java
public class AFactoryImpl implements AFactory{
    public void say() {
        System.out.println("i am A factory");
    }
}
```

一个BFactory的接口
```java
public interface BFactory {
    int add(int i,int j);
}
```

一个BFactory的实现类
```java
public class BFactoryImpl implements BFactory{
    public int add(int i, int j) {
        return i+j;
    }
}
```

上面就是所需要的组件了。

动态代理的核心是实现一个InvocationHandler接口的处理器：
```java
public class Handler implements InvocationHandler {
    // 被代理的对象，之所以是Object类型的，是因为希望它能够适配更多的被代理对象
    private Object target;

    // 构造器
    public Handler(Object target) {
        this.target = target;
    }

    // 获得一个代理对象
    public Object newProxyInstance(){
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }
    
    // 利用代理对象来执行被代理对象的方法
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("前置增强");
        Object ret = method.invoke(target,args);
        System.out.println("后置增强");
        return ret;
    }
}
```

通过测试代码跑通：
```java
public class DynamicProxy {
    public static void main(String[] args) {
        AFactory a = new AFactoryImpl();
        Handler h1 = new Handler(a);
        AFactory aProxy = (AFactory) h1.newProxyInstance();
        aProxy.say();
s
        BFactory b = new BFactoryImpl();
        Handler h2 = new Handler(b);
        BFactory bProxy = (BFactory) h2.newProxyInstance();
        System.out.println(bProxy.add(5,6));
    }
}
```

运行的结果是：
```java
前置增强
i am A factory
后置增强
前置增强
后置增强
11
```

以上就是jdk动态代理的简单例子。这没啥好说的。。。下面尝试着看一下jdk动态代理的原理。

首先先获取到代理对象。代理对象是通过jvm动态生成的，由本例中代码获得
```java
AFactory aProxy = (AFactory) h1.newProxyInstance();

```
```java
    // 获得一个代理对象
    public Object newProxyInstance(){
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }
```
其中Proxy类的注释是这个样子滴：
```
provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods
```
看不懂？没关系，谷歌翻译一下
```
提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类
```
也就是数Proxy是所有生成的代理对象的父类。其中他有一个很重要的静态函数就是newProxyInstance。该方法返回指定接口的代理类的实例，该实例将方法调用分派到指定的调用处理程序.
```java
/**
Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler.
*/
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)
        throws IllegalArgumentException
{
    Objects.requireNonNull(h);

    final Class<?>[] intfs = interfaces.clone();
    final SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
    }

    /*
     * Look up or generate the designated proxy class.
     * 查找或生成指定的代理类。
     */
    Class<?> cl = getProxyClass0(loader, intfs);
    /*
    * Invoke its constructor with the designated invocation handler.
    */
    try {
        if (sm != null) {
            checkNewProxyPermission(Reflection.getCallerClass(), cl);
        }

        // 获取代理类的构造器
        final Constructor<?> cons = cl.getConstructor(constructorParams);
        final InvocationHandler ih = h;
        // 如果构造器不是public类型的，设置setAccessible为true
        if (!Modifier.isPublic(cl.getModifiers())) {
            AccessController.doPrivileged(new PrivilegedAction<Void>() {
                public Void run() {
                    cons.setAccessible(true);
                    return null;
                }
            });
        }
        // 根据构造器来new一个对象，并传递InvocationHandler h
        return cons.newInstance(new Object[]{h});
    } catch (IllegalAccessException|InstantiationException e) {
        throw new InternalError(e.toString(), e);
    } catch (InvocationTargetException e) {
        Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new InternalError(t.toString(), t);
        }
    } catch (NoSuchMethodException e) {
        throw new InternalError(e.toString(), e);
    }
}
```
这个函数首先会先从jvm缓存中查询是否有创建过的代理类，如果有的话，则从缓存中获得，如果没有，则新建一个代理类。
```java
Class<?> cl = getProxyClass0(loader, intfs);

/**
Generate a proxy class.  Must call the checkProxyAccess method to perform permission checks before calling this.
生成代理类。 在调用此方法之前，必须调用checkProxyAccess方法执行权限检查。
*/
private static Class<?> getProxyClass0(ClassLoader loader,
Class<?>... interfaces){
    if (interfaces.length > 65535) {
        throw new IllegalArgumentException("interface limit exceeded");
    }

/**
if the proxy class defined by the given loader implementing the given interfaces exists, this will simply return the cached copy;otherwise, it will create the proxy class via the ProxyClassFactory
*/
/**
如果存在由实现了给定接口的给定加载器定义的代理类，则将仅返回缓存的副本；否则，它将通过ProxyClassFactory创建代理类
*/
    return proxyClassCache.get(loader, interfaces);
}
```
这个函数就是上面proxyClassCashe.get的源代码

```java
public V get(K key, P parameter) {
    Objects.requireNonNull(parameter);

    expungeStaleEntries();

    Object cacheKey = CacheKey.valueOf(key, refQueue);

    // lazily install the 2nd level valuesMap for the particular cacheKey懒地为特定的cacheKey安装第二级valuesMap
    ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);
    if (valuesMap == null) {
        ConcurrentMap<Object, Supplier<V>> oldValuesMap
            = map.putIfAbsent(cacheKey,
                                valuesMap = new ConcurrentHashMap<>());
        if (oldValuesMap != null) {
            valuesMap = oldValuesMap;
        }
    }

    // create subKey and retrieve the possible Supplier<V> stored by that subKey from valuesMap 
    // 创建subKey并从valuesMap中检索该subKey存储的可能的Supplier <V>
    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
    Supplier<V> supplier = valuesMap.get(subKey);
    Factory factory = null;

    while (true) {
        if (supplier != null) {
            // supplier might be a Factory or a CacheValue<V> instance
            V value = supplier.get();
            if (value != null) {
                return value;
            }
        }
        // else no supplier in cache
        // or a supplier that returned null (could be a cleared CacheValue
        // or a Factory that wasn't successful in installing the CacheValue)

        // lazily construct a Factory
        if (factory == null) {
            factory = new Factory(key, parameter, subKey, valuesMap);
        }

        if (supplier == null) {
            supplier = valuesMap.putIfAbsent(subKey, factory);
            if (supplier == null) {
                // successfully installed Factory
                supplier = factory;
            }
            // else retry with winning supplier
        } else {
            if (valuesMap.replace(subKey, supplier, factory)) {
                // successfully replaced
                // cleared CacheEntry / unsuccessful Factory
                // with our Factory
                supplier = factory;
            } else {
                // retry with current supplier
                supplier = valuesMap.get(subKey);
            }
        }
    }
}
```
具体的创建代理对象的字节码是在下面这一行代码里面进行的
```java
Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
```
<font color="red">这里有个二级缓存的问题,暂时没有想明白。。。</font>

调用的就是java.lang.reflect.Proxy.ProxyClassFactory中的apply()方法
```java
@Override
public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {

    Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
    for (Class<?> intf : interfaces) {
        /*
        * Verify that the class loader resolves the name of this
        * interface to the same Class object.
        */
        Class<?> interfaceClass = null;
        try {
            interfaceClass = Class.forName(intf.getName(), false, loader);
        } catch (ClassNotFoundException e) {
        }
        if (interfaceClass != intf) {
            throw new IllegalArgumentException(
                intf + " is not visible from class loader");
        }
        /*
        * Verify that the Class object actually represents an
        * interface.
        */
        if (!interfaceClass.isInterface()) {
            throw new IllegalArgumentException(
                interfaceClass.getName() + " is not an interface");
        }
        /*
        * Verify that this interface is not a duplicate.
        */
        if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
            throw new IllegalArgumentException(
                "repeated interface: " + interfaceClass.getName());
        }
    }

    String proxyPkg = null;     // package to define proxy class in
    int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

    /*
    * Record the package of a non-public proxy interface so that the
    * proxy class will be defined in the same package.  Verify that
    * all non-public proxy interfaces are in the same package.
    */
    for (Class<?> intf : interfaces) {
        int flags = intf.getModifiers();
        if (!Modifier.isPublic(flags)) {
            accessFlags = Modifier.FINAL;
            String name = intf.getName();
            int n = name.lastIndexOf('.');
            String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
            if (proxyPkg == null) {
                proxyPkg = pkg;
            } else if (!pkg.equals(proxyPkg)) {
                throw new IllegalArgumentException(
                    "non-public interfaces from different packages");
            }
        }
    }

    if (proxyPkg == null) {
        // if no non-public proxy interfaces, use com.sun.proxy package
        proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
    }

    /*
    * Choose a name for the proxy class to generate.
    */
    long num = nextUniqueNumber.getAndIncrement();
    String proxyName = proxyPkg + proxyClassNamePrefix + num;

    /*
    * Generate the specified proxy class.
    */
    byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
        proxyName, interfaces, accessFlags);
    try {
        return defineClass0(loader, proxyName,
                            proxyClassFile, 0, proxyClassFile.length);
    } catch (ClassFormatError e) {
        /*
        * A ClassFormatError here means that (barring bugs in the
        * proxy class generation code) there was some other
        * invalid aspect of the arguments supplied to the proxy
        * class creation (such as virtual machine limitations
        * exceeded).
        */
        throw new IllegalArgumentException(e.toString());
    }
}
}
```

