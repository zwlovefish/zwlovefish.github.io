---
title: 容器的基本实现
date: 2021-06-03 20:56:25
tags: 容器的基本实现
categories: spring源码深度解析
---
以XmlBeanFactory为例
<!-- more -->
# 配置文件的封装
首先哈，先将xml文件包装成Resource类，然后通过super(parentBeanFactory)来设置实现了某些接口的类不通过此处注入。
![配置文件的封装](配置文件的封装.png)
# 加载bean
将上一步的资源类包装成EncodeResource(EncodeResource的作用是以某种编码方式读取Resource的流数据)，在通过EncodeResource获取InputStream，将该资源的InputStream包装成InputSource类处理，接着将资源类以2种方式(DTD和XSD)之一的验证模式获取(应该叫new一个)Document对象
![加载bean](加载bean.png)
# 解析及注册beanDefinitions
根据doc来注册bean，这里使用了模板类设计模式
![解析及注册beanDefinitions](解析及注册beanDefinitions.png)
这里先解析的profile，profile的用法
```xml
<beans xmlns="...">
    <beans profile="dev">
        ...
    </beans>
    <beans profile="production">
        ...
    </beans>
</beans>
```
集成到web环境时，在web.xml时中加入一下代码
```xml
<context-param>
    <param-name>Spring.profiles.active</param-name>
    <param-value>dev</param-value>
</context-param>
```
这样可以在配置文件中配置2套配置，springboot的原理就是在这里了。
![parseBeanDefinitions](parseBeanDefinitions.png)

# 解析默认空间的bean
## parseDefaultElement
```java
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
        importBeanDefinitionResource(ele);
    }
    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
        processAliasRegistration(ele);
    }
    // BEAN_ELEMENT是bean，以此为例
    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
        processBeanDefinition(ele, delegate);
    }
    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
        doRegisterBeanDefinitions(ele);
    }
}
```
 
## processBeanDefinition
```java
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    // 这里就解析完成了bean的id，name，class和alias属性
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
    if (bdHolder != null) {
        // 这里解析子节点的自定义属性
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            // 注册bdHolder
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error("Failed to register bean definition with name '" +
                    bdHolder.getBeanName() + "'", ele, ex);
        }
        // 通知相关的监听器，这个bean已经加载完了
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}
```
### parseBeanDefinitionElement
```java
// ele:<bean id="..." name="..." class="..."> containingBean:null
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
    // 解析id属性
    String id = ele.getAttribute(ID_ATTRIBUTE);
    // 解析name属性
    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

    // 分割name属性
    /**
        * 所以spring bean设置别名有2种方式
        1.使用alias
        <bean id="app:dataSource" class="...">
        <alias name="app:dataSoure" alias="user:dataSoure"/>
        <alias name="app:dataSoure" alias="device:dataSoure"/>
        </bean>

        2.使用name
        <bean id="app:dataSource" class="..." name="user:dataSoure,device:dataSoure"">
        </bean>
    **/
    List<String> aliases = new ArrayList<>();
    if (StringUtils.hasLength(nameAttr)) {
        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
        aliases.addAll(Arrays.asList(nameArr));
    }

    String beanName = id;
    // 没有id属性，有name属性，使用name的第一个作为bean name，其他的作为alias
    if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
        beanName = aliases.remove(0);
    }

    // 检测name的唯一性
    if (containingBean == null) {
        checkNameUniqueness(beanName, aliases, ele);
    }

    // 进一步解析其他所有属性并统一分装到GenericBeanDefinition种
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
    if (beanDefinition != null) {
        // 如果不存在beanName的话，则使用默认规则生成beanName
        if (!StringUtils.hasText(beanName)) {
            try {
                if (containingBean != null) {
                    beanName = BeanDefinitionReaderUtils.generateBeanName(
                            beanDefinition, this.readerContext.getRegistry(), true);
                }
                else {
                    beanName = this.readerContext.generateBeanName(beanDefinition);
                    String beanClassName = beanDefinition.getBeanClassName();
                    if (beanClassName != null &&
                            beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                        aliases.add(beanClassName);
                    }
                }
            }
            catch (Exception ex) {
                error(ex.getMessage(), ele);
                return null;
            }
        }
        String[] aliasesArray = StringUtils.toStringArray(aliases);

        //返回实例
        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
    }
    return null;
}
```

#### parseBeanDefinitionElement
```java
public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, @Nullable BeanDefinition containingBean) {

	this.parseState.push(new BeanEntry(beanName));

    // 解析class的属性
    String className = null;
    if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
    }
    // 解析parent属性
    String parent = null;
    if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
        parent = ele.getAttribute(PARENT_ATTRIBUTE);
    }

    
    // 创建用于承载属性的GenericBeanDefinition，
    // GenericBeanDefinition是AbstractBeanDefinition的子类
    // Sprinh通过BeanDefinition将配置文件中的<bean>配置信息转换为容器的内部表示，并将这些BeanDefinition
    // 注册到BeanDefinitionRegistry中。并以map形式存储，后续操作直接从BeanDefinitionRegistry中读取配置信息
    AbstractBeanDefinition bd = createBeanDefinition(className, parent);
    // 解析bean的各种属性，使用bd的set方法填充值
    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

    // 解析元数据
    parseMetaElements(ele, bd);
    // 解析lookup-method属性
    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
    // 解析replaced-method属性
    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

    // 解析构造函数参数
    parseConstructorArgElements(ele, bd);
    // 解析property子元素
    parsePropertyElements(ele, bd);
    // 解析qualifier子元素
    parseQualifierElements(ele, bd);

    bd.setResource(this.readerContext.getResource());
    bd.setSource(extractSource(ele));

    return bd;
}
```
至此完成了对XML文档到GenericBeanDefinition的转换，也就说到这里，XML中所有的配置都可以在GenericBeanDefinition的实例类中找到对应的配置
GenericBeanDefinition只是子类实现，而大部分的通用属性都保存到了AbstractBeanDefinition中。

后续没有深入挖掘了...
### decorateBeanDefinitionIfRequired

### 注册和通知相关的监听器没往下看。。。。。
#### registerBeanDefinition
```java
public static void registerBeanDefinition(
        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
        throws BeanDefinitionStoreException {

    // Register bean definition under primary name.
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // Register aliases for bean name, if any.
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}
```
#### registry.registerBeanDefinition
```java
public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {
    if (beanDefinition instanceof AbstractBeanDefinition) {
        // 注册前的最后以此校验，这里的校验不同于之前的XML校验，
        // 主要是对于AbstractBeanDefinition属性中的methodOverrides(在解析lookup和replacemethod时使用的)校验
        // 校验methodOverrides是否与工厂方法并存或者methodOverrides对应的方法个根本不存在
        try {
            ((AbstractBeanDefinition) beanDefinition).validate();
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    "Validation of bean definition failed", ex);
        }
    }

    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
    if (existingDefinition != null) {
        // 如果对应的BeanName已经注册且在配置中配置了不允许bean被覆盖的话，则跑出异常
        if (!isAllowBeanDefinitionOverriding()) {
            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
        }
        
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }
    else {
        if (hasBeanCreationStarted()) {
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                removeManualSingletonName(beanName);
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            removeManualSingletonName(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    // 清除解析之前留下的对应的beanName的缓存
    if (existingDefinition != null || containsSingleton(beanName)) {
        resetBeanDefinition(beanName);
    }
    // Whether bean definition metadata may be cached for all beans.
    /**
	 * 
        Remove any assumptions about by-type mappings.
        private void clearByTypeCache() {
            this.allBeanNamesByType.clear();
            this.singletonBeanNamesByType.clear();
        }
    */
    else if (isConfigurationFrozen()) {
        clearByTypeCache();
    }
}
```
#### registry.registerAlias
```java
@Override
public void registerAlias(String name, String alias) {
    synchronized (this.aliasMap) {
        // 如果beanName与alias相同的话不记录alias，并删除对应的alias
        if (alias.equals(name)) {
            this.aliasMap.remove(alias);
        }
        else {
            String registeredName = this.aliasMap.get(alias);
            if (registeredName != null) {
                if (registeredName.equals(name)) {
                    // An existing alias - no need to re-register
                    return;
                }
                // 如果alias不允许被覆盖则跑出异常
                if (!allowAliasOverriding()) {
                    throw new IllegalStateException("Cannot define alias '" + alias + "' for name '" +
                            name + "': It is already registered for name '" + registeredName + "'.");
                }
            }
            // a->b->c->a存在环时，不被允许的
            checkForAliasCircle(name, alias);
            this.aliasMap.put(alias, name);
        }
    }
}
```
### 通知监听器解析及注册完成
这里的实现只为扩展，当程序开发人员需要对注册BeanDefinition事件进行监听时可以通过注册监听器的方式并将处理逻辑写入监听器中，目前在spring中并没有对此事件做任何逻辑的处理

## alias标签的解析
```xml
<beans>
    <bean id="testBean" class="com.zhou.Test"></bean>
    <alias name="testBean" alias="testBean1,testBean2"> </alias>
</beans>
```
```java
/**
    * Process the given alias element, registering the alias with the registry.
    */
protected void processAliasRegistration(Element ele) {
    String name = ele.getAttribute(NAME_ATTRIBUTE);
    String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
    boolean valid = true;
    if (!StringUtils.hasText(name)) {
        valid = false;
    }
    if (!StringUtils.hasText(alias)) {
        valid = false;
    }
    if (valid) {
        // 注册alias
        getReaderContext().getRegistry().registerAlias(name, alias);
        // 别名注册后通知监听器做相应的处理
        getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
    }
}
```

## import标签的解析
```xml
<beans>
    <import resource="customerContext.xml"></import>
    <import resource="systemContext.xml"></import>
</beans>
```
```java
protected void importBeanDefinitionResource(Element ele) {
    // 获取resource的属性
    String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
    // 如果不存在resource属性则不作处理
    if (!StringUtils.hasText(location)) {
        getReaderContext().error("Resource location must not be empty", ele);
        return;
    }


    // 解析系统属性: 例如 "${user.dir}"
    location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

    Set<Resource> actualResources = new LinkedHashSet<>(4);

    // 判断location是绝对路径还是相对路径
    boolean absoluteLocation = false;
    try {
        absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
    }
    catch (URISyntaxException ex) {
        // cannot convert to an URI, considering the location relative
        // unless it is the well-known Spring prefix "classpath*:"
    }

    if (absoluteLocation) {
        // 如果是绝对路径，则根据直接地址加载对应的配置文件
        try {
            int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(
                    "Failed to import bean definitions from URL location [" + location + "]", ele, ex);
        }
    }
    else {
        // 如果是相对地址，则根据相对地址计算出绝对地址
        try {
            int importCount;
            // Resources存在多个子类实现类，如VfsResource、FileSystemResource
            // 而每个resource的createRelative方式实现都不一样，所以这里先采用子类的方法尝试解析
            Resource relativeResource = getReaderContext().getResource().createRelative(location);
            if (relativeResource.exists()) {
                importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
                actualResources.add(relativeResource);
            }
            // 如果解析不成功，则使用默认的解析器ResourcePatternResolver进行解析
            else {
                String baseLocation = getReaderContext().getResource().getURL().toString();
                importCount = getReaderContext().getReader().loadBeanDefinitions(
                        StringUtils.applyRelativePath(baseLocation, location), actualResources);
            }
        }
        catch (IOException ex) {
            getReaderContext().error("Failed to resolve current resource location", ele, ex);
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(
                    "Failed to import bean definitions from relative location [" + location + "]", ele, ex);
        }
    }
    // 解析后进行监听器激活处理
    Resource[] actResArray = actualResources.toArray(new Resource[0]);
    getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
}
```
## 嵌入式标签的解析
递归调用beans的解析过程，仅此而已