---
title: mapReduce
date: 2021-10-19 21:43:11
tags: mapReduce
categories: 论文阅读
---
# Abstract
MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify amapfunction that processes a key/value pair to generate a set of intermediate key/value pairs, and areducefunction that merges all intermediate values associated with the same intermediate key. Many real world tasks are expressible in this model, as shown in the paper.MapReduce是一个用于处理和生成大型数据集的编程模型和相关实现。用户指定一个map函数来处理一个键值对以生成一组中减键值对，指定一个reduce函数通过中间键值对的键来merge这组中间键值对，许多真实世界的任务都可以用本论文的模型来表达。

<!-- more -->
Programs written in this functional style are automatically parallelized and executed on a large cluster of commodity machines. The run-time system takes care of the details of partitioning the input data, scheduling the program’s execution across a set of machines, handling machine failures, and managing the required inter-machine communication. This allows programmers without any experience with parallel and distributed systems to easily utilize the resources of a large distributed system.以这种功能风格编写的程序会自动并行化，并在大型商用机器集群上执行。运行系统负责对输入数据进行分区、在一组机器上调度程序的执行、处理机器故障以及管理所需的机器间通信等细节。这使得没有任何并行和分布式系统经验的程序员可以轻松地利用大型分布式系统的资源。

Our implementation of MapReduce runs on a large cluster of commodity machines and is highly scalable: a typical MapReduce computation processes many terabytes of data on thousands of machines. Programmers find the system easy to use: hundreds of MapReduce programs have been implemented and upwards of one thousand MapReduce jobs are executed on Google’s clusters every day.我们的MapReduce实现运行在一个大型的商用机器集群上，并且具有高度的可伸缩性:一个典型的MapReduce计算在数千台机器上处理以兆字节为单位的数据。程序员发现这个系统很容易使用:已经实现了上百个MapReduce程序，每天在谷歌的集群上执行超过1000个MapReduce任务。
# Introduction
Over the past five years, the authors and many others at Google have implemented hundreds of special-purpose computations that process large amounts of raw data,such as crawled documents, web request logs, etc., to compute various kinds of derived data, such as inverted indices, various representations of the graph structure of web documents, summaries of the number of pages crawled per host, the set of most frequent queries in a given day, etc. Most such computations are conceptually straight forward. However, the input data is usually large and the computations have to be distributed across hundreds or thousands of machines in order to finish in a reasonable amount of time. The issues of how to parallelize the computation, distribute the data, and handle failures conspire to obscure the original simple computation with large amounts of complex code to deal with these issues.在过去的5年中，作者和其他人在谷歌实现了数以百计的具有特殊目的的计算程序用来处理大量的原始数据，例如crawled documents，web请求日志等等，计算各种派生数据，例如倒排索引，web文档的图形结构的各种表示，每个主机抓取的页面数的摘要，给定一天中最频繁的查询集等等。大多数这样的计算在概念上都很简单。然而，输入数据通常很大，为了在合理的时间内完成计算，必须分布在数百或数千台机器上。如何并行化计算、分发数据和处理故障的问题，合起来掩盖了原始的简单计算，并使用大量复杂的代码来处理这些问题。

As a reaction to this complexity, we designed a new abstraction that allows us to express the simple computations we were trying to perform but hides the messy details of parallelization, fault-tolerance, data distribution and load balancing in a library. Our abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages. We realized that most of our computations involved applying a map operation to each logical “record” in our input in order to compute a set of intermediate key/value pairs, and then applying a reduce operation to all the values that shared the same key, in order to combine the derived data appropriately. Our use of a functional model with user-specified map and reduce operations allows us to parallelize large computations easily and to use re-execution as the primary mechanism for fault tolerance.作为对这种复杂性的反应，我们设计了一个抽象，它允许我们试图执行的简单计算，但是隐藏了库中并行化，容错，数据分发和负载平衡。我们的抽象受到了List以及其他函数式语言中的map和reduce的启发。我们意识到计算中的大部分都是将输入的逻辑record通过一个map操作来计算一组中间键值对。然后对所有相同key的值做reduce操作以便将派生的数据组合起来。我们使用用户指定的map和reduce操作的函数模型，使我们能够轻松地并行化大型计算，并使用重新执行作为容错的主要机制。

The major contributions of this work are a simple and powerful interface that enables automatic parallelization and distribution of large-scale computations, combined with an implementation of this interface that achieves high performance on large clusters of commodity PCs.这项工作的主要贡献是一个简单而强大的接口，能够进行自动的并行和大规模的分布式计算，该接口的实现能够在大型商用pc集群上实现高性能。

Section 2 describes the basic programming model and gives several examples. Section 3 describes an implementation of the MapReduce interface tailored towards our cluster-based computing environment. Section 4 describes several refinements of the programming model that we have found useful. Section 5 has performance measurements of our implementation for a variety of tasks. Section 6 explores the use of MapReduce within Google including our experiences in using it as the basis for a rewrite of our production indexing system. Section 7 discusses related and future work.第2节描述了基本的编程模型并给出几个例子。第3节描述了基于集群的计算环境定制的MapReduce接口的实现。第4节描述了我们认为有用的编程模型的几个改进。第5节描述了我们对各种任务的实现的性能度量。第6节探讨了MapReduce在 Google 中的使用，包括我们将其用作重写生产索引系统的基础的经验。第7节描述了相关和未来的工作。