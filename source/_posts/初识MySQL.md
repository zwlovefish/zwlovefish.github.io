---
title: 初识MySQL
date: 2022-03-29 23:00:13
tags: 初识MySQL,MySQL文件
categories: MySQL
---
MySQL使用TCP作为MySQL服务器程序和客户端程序之间的网络通信协议。

# MySQL服务器启动脚本

**mysqld** 执行mysqld可以打开一个MySQL进程
**mysqld_safe** 执行mysqld_safe会间接调用mysqld，并监控其状态， 如果MySQL服务器出现错误，会重新启动服务器程序，并将出错信息打印到日志
**mysql.server** 间接调用mysqld_safe，执行**mysql.server start/stop**即可开启和关闭MySQL服务器程序。
**mysql_mysqld_muti** 可以在一台机器上启动多个MySQL服务器示例
![查询请求执行过程](查询请求执行过程.png)
<!--more-->

# 配置文件

配置文件位置，类Unix会按照如表1所示路径查找配置文件
表1：
|路径名|备注
|:--:|:--:|
|/etc/my.cnf||
|/etc/mysql/my.cnf||
|SYSCONFDIR/my.cnf||
|$MYSQL_HOME/my.cnf|特定与服务器的选项(仅限于服务器
|defaults-extra-file|命令行指定的额外配置文件路径|
|~/.my.cnf|特定于用户的选项|
|~/.mylogin.cnf|特定于用户的登录路径选项(仅限于客户端)|

**注意：**
1. SYSCONFDIR表示在使用CMake构建MySQL时使用SYSCONFDIR选项指定的目录
2. .mylogin.cnf不是一个纯文本文件，只能使用mysql_config_editor实用程序处理

## 配置文件的内容

配置文件中的等号左右可以有空白符，而命令行不行，命令行不能有空白符。
可以在选项组的名称后加上特定的版本号，这样只能由该版本的程序使用该选项组的选项。eg.[mysqld-5.7]这样，只有版本为5.7的mysqld才能使用该选项组的选项
[server]
(具体的启动选项)
eg. 
option1             #该选项不需要选项值
option2 = value2    #该选项需要选项值
[mysqld]
(具体的启动选项)
[mysqld_safe]
(具体的启动选项)
[client]
(具体的启动选项)
[mysql]
(具体的启动选项)
[mysqladmin]
(具体的启动选项)

[server]组里面的配置适用于所有的MySQL服务器程序
[client]组里面的配置适用于所有的client客户端程序

|程序名|类别|能读取的组|
|:--:|:--:|:--:|
|mysqld|启动服务器|[mysqld]、[server]|
|mysqld_safe|启动服务器|[mysqld]、[server]、[mysqld_safe]|
|mysql.server|启动服务器|[mysqld]、[server]、[mysql.server]|
|mysql|启动客户端|[mysql]、[client]|
|mysqladmin|启动客户端|[mysqladmin]、[client]|
|mysqldump|启动客户端|[mysqldump]、[client]|

## 配置文件的优先级

**配置文件的优先级**:会按照表1的顺序依次读取各个配置文件。如果多个路径下的配置文件中含有相同的属性，以最后一个为准。eg.在/etc/my.cnf中配置了default-storage-engine=InnoDB，在~/.my.cnf中配置default-storage-engine=MyISAM。则以MyISAM为准。
**同配置文件多个组的优先级**:以最后一个组中的启动选项为准。eg.在/etc/my.cnf中出现
"配置文件与命令行的优先级":如果同一个选项出现在配置文件中和命令行中，则以命令行中的选项为准。
[server]
default-storeage-engine=InnDB
[client]
default-storeage-engine=MyISAM
则以MyISAM为准

<font color='red'>
default-extra-file和default-fifle分表表示额外配置和默认配置选项，只能用于命令行中
</font>

# 系统变量

1. 作用范围
    多个客户端程序可以连接同一个MySQL服务器程序。对于同一个系统变量，想让不同的客户端有不同的值，eg.客户端A想把default_storage_engine设置为MyISAM，客户端B想把default_storage_engine设置为InnoDB。MySQL有作用范围的概念——GLOBAL和SESSION。
    **GLOBAL**:影响MySQL服务器的整体操作
    **SESSION**:影响某个客户端连接的操作
    服务器启动时，会将每个全局系统变量初始化为其默认值。服务器还为每个客户端维护一组会话系统变量。客户端的会话变量在连接时使用相应全局系统变量的当前值进行初始化。
    eg.以default_storage_engine为例，MySQL服务器启动时会初始化一个名为default_storage_engine，作用范围为GLOBAL的系统变量，之后每当有客户端连接服务器时，服务器都会单独为该客户端分配一个名为default_storage_engine，作用范围为SESSION的系统变量，这个作用范围为SESSION的系统变量值按照当前作用范围为GLOBAL的同名系统变量值初始化而来。
2. 查看系统变量
    ```shell
    SHOW VARIABLES [LIKE 匹配模式]
    SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配模式]
    ```

3. 设置方式
- 启动项设置
- 服务器程序运行时设置
    ```shell
    SET [GLOBAL|SESSION] 系统变量名 = 值。
    SET [@@(GLOBAL|SESSION).]系统变量名 = 值。
    ```
    eg.
    设置全局系统变量名
    SET GLOBAL default_storage_engine=InnoDB
    SET @@GLOBAL.default_storage_engine=InnoDB
    设置会话系统变量名
    SET SESSION default_storage_engine=InnoDB
    SET @@SESSION.default_storage_engine=InnoDB
    SET default_storage_engine=InnoDB # 由此可见默认的作用范围是SESSION

# 状态变量

MySQL服务器程序中维护了关于程序运行状态的变量，称为状态变量。比如Threads_connected等，由于状态变量是用来显示服务器程序运行状态的，所以他们的值只能由服务器程序自己设置，不能认为设置。与系统变量类似，状态变量也有GLOBAL和SESSION之分。
查看状态变量
```shell
SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配模式]
```
如果不加修饰符，默认作用范围为SESSION

# 字符集和比较规则

## 查看和比较规则
```mysql
SHOW [CHARACTER SET|CHARSET] [LIKE 匹配规则] #字符集的查看
SHOW COLLATION [LIKE 匹配规则] #比较规则的查看
```
![比较规则名称后缀英文释义及描述](比较规则名称后缀英文释义及描述.png)
## MySQL的字符集与比较规则
每种字符集对应着若干比较规则。且每种字符集都有一种默认的比较规则
MySQL有4种级别的字符集和比较规则：
1. 服务器级别
character_set_server：表示服务器级别的字符集
collation_server:表示服务器级别的字符集
2. 数据库级别
character_set_database: 表示数据库级别的字符集
collation_database: 表示数据库级别的字符集
3. 表级别
    ```mysql
    # 创建时指定字符集和比较规则
    CREATE TABLE 表名 (
        列的信息
    ) [[DEFAULT] CHARACTER SET 字符集名称][COLLATION 比较规则名称]

    # 修改时指定字符集和比较规则
    ALTER TABLE 表名 [[DEFAULT] CHARACTER SET 字符集名称][COLLATION 比较规则]
    ```
4. 列级别
    ```mysql
    # 创建时指定字符集和比较规则
    CREATE TABLE 表名 (
        列名 字符串类型 [CHARACTER SET 字符集名称][COLLATION 比较规则]
    )

    # 修改时指定字符集和比较规则
    ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称][COLLATION 比较规则]
    ```
    
如果查到的字符是乱码，可以查看**字符集**
如果ORDER BY 列名 排序的结果不是自己想要的，可以查看**比较规则**

**小结**
- 只修改字符集，则比较规则变为修改后字符集的默认比较规则
- 只修改规则，则字符集将变为修改后的比较规则对应的字符集
- 如果创建列时没有显示的指定字符集和比较规则，默认使用表的字符集和比较规则
- 如果创建表时没有显示的指定字符集和比较规则，默认使用数据库的字符集和比较规则
- 如果创建数据库时没有显示的指定字符集和比较规则，默认使用数据MySQL服务器程序的字符集和比较规则

## 客户端与服务器通信过程中使用的字符集
![client与server通信过程中使用的字符集](client与server通信过程中使用的字符集.png)

**补充说明**
- 1中默认是以操作系统的字符集对请求的字符串编码，在windows中如果指定default-character-set启动项，则以该启动项对请求编码，如果客户端不支持操作系统的字符集则按照mysql默认的字符集编码
- <font color='red'>3-4在书中没看懂啊。。。</font>
- character_set_client、character_set_connection、character_set_results均是session级别的，针对每个客户端的连接，服务器都会为该连接维护这三个变量

# InnoDB存储结构
## InnoDB页
内存与磁盘的读写速度差了几个数量级，因此InnoDB采取的方式是将数据分为若干个页，以页为单位进行读取，页的大小一般为16KB，一次最少从磁盘上读取16KB的内容到内存，一次最少把内存中的16KB内容刷到磁盘上。

系统变量innodb_page_size表明了InnoDB存储引擎的也大小，默认值为16384(16KB)。该变量只能在第一次初始化MySQL数据目录时指定，之后就不能更改了，通过命令mysqld --initialize来初始化数据目录。
## InnoDB行结构
有4中行格式：Compact、Redundant、Dynamic和Comprssed行格式
### 指定行结构语法
```shell
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```
### COMPACT行格式
![Compact的行格式图](Compact的行格式图.png)
- **变长字段列表**
MySQL支持一些变长的数据类型，例如varchar,varbinary等，这些字段称为变长字段。这些变长字段存储的长度不是固定的，所以MySQL在存储时需要把这些字段存起来。也就是说变长字段存储的空间分为2部分，一部分是真实数据存储在记录的真实数据中，一部分是该数据的占用的字节数，存储在记录的额外信息的变长字段长度列表中。所有变长字段的真实数据所占用的字节数按照<font color='red'>逆序</font>记录在记录的额外信息中从而形成一个可变字段长度列表。例如记录'aaaa','bbb','cc','d'的可变长列表就是01 02 03 04。
如何确认是按照1字节还是2字节来表示一个变长字段的真实数据所占用的字节数呢？如果该变长字段允许的最大字节数超过255字节，则根据真实的长度(L)来计算，如果L超过127字节则使用2字节来表示，否则使用1字节
- **NULL值列表**
首先统计表中允许存储NULL的列有哪些，如果表中没有允许存储NULL的列，那么NULL值列表也就不存在了。否则的话，每个允许存储NULL的列也是按照<font color="red">逆序</font>对应一个比特位，1代表NULL，0代表有值。如果允许存储NULL值的列的个数必须使用整数个字节数表示，例如如果有9个允许存储NULL的列，就需要使用2字节来表示了
- **记录头信息**
记录头信息由固定的5个字节40个比特位组成，记录头信息的40个比特位也叫做info bit。具体如下表所示：

    |名称|大小(位)|描述|
    |:-:|:-:|:-:|
    |预留位 1|1|没有使用|
    |预留位 2|1|没有使用|
    |deleted_flag|1|标记该记录是否被删除|
    |min_rec_flag|1|B+数的每层非叶子节点中最小的目录项记录都会添加该标记|
    |n_owned|4|一个页面中的记录会被分成若干个小组，每个小组有一个记录是"带头大哥",其余的记录都是"小弟"，"带头大哥"记录的n_owned代表该组的所有记录条数，"小弟"的记录的o_owned为0|
    |heap_no|13|表示当前记录在页面堆中的相对位置|
    |record_type|3|表示记录的类型<br>0:普通记录<br>1:B+树非叶子节点的目录项记录<br>2:Infimum记录<br>3:Supremum记录
    |next_record|16|表示下一条记录的相对位置|
- 记录的真实数据
    MySQL会为每个记录默认的添加一些列，如下所示：
    |列名|是否必须|占用空间|描述|
    |:--:|:--:|:--|:--:|
    |row_id|否|6字节|行ID，唯一标识一条记录|
    |trx_id|是|6字节|事务ID|
    |roll_pointer|是|7字节|回滚指针|

    InnoDB的主键生成策略：优先使用用户自定义的主键，如果用户没有定义主键，则选取第一个不允许存储NULL值的UNIQUE键作为主键，如果以上都不满足，则InnoDB会为表添加一个默认的名为row_id的列作为主键。如果有满足的条件，它就不会被添加了。
- CHAR(M)列的存储格式
如果存储的编码集是固定长度的，则其属于可变长字段，否则属于可变长字段

### REDUNDANT行格式
![Redundant的行格式图](Redundant的行格式图.png)
- **字段长度偏移列表**
把一条记录的所有列(包括隐藏列)的长度信息按照<font color="red">逆序</font>存储到字段长度列表。长度信息是利用2个相邻偏移量的差值来计算各个列值的长度。例如25 24 1A 17 13 0C 06，因为它是按照逆序排放的，所以按照列的长度排列就是06 0C 13 17 1A 24 25,第一列6个字节，第二列0C-06=6个字节，第三列13-0C=7个字节，第四列17-13=4个字节，第五列1A-17=3个字节，第六列24-1A=10个字节，第七列25-25=1个字节
- **记录头信息**
    记录头信息占用6字节，共使用48个比特位
    |名称|大小(位)|描述|
    |:--:|:--:|:--:|
    |预留位 1|1|没有使用|
    |预留位 2|2|没有使用|
    |deleted_flag|1|标记该记录是否被删除|
    |min_rec_flag|1|B+树的每层非叶子节点中的最小的目录项记录都会添加该标记|
    |n_owned|4|一个页面中的记录会被分成若干个小组，每个小组有一个记录是"带头大哥",其余的记录都是"小弟"，"带头大哥"记录的n_owned代表该组的所有记录条数，"小弟"的记录的o_owned为0|
    |heap_no|13|表示当前记录在页面堆中的相对位置|
    |n_field|10|表示记录中列的数量|
    |1byte_offs_flag|1|标记字段长度偏移表中每个列对应的偏移量是使用1字节还是2字节表示的|
    |next_record|16|表示下一条记录的相对位置|

    1byte_offs_flag取值表示：1表示1字节存储偏移量，0表示2字节存储偏移量。当记录的真实数据占用的字节数不大于127时，1byte_offs_flag表示1字节；当记录的真实数据占用的字节数大于127(0x7f)，但是不大于32767(0x7fff)时，1byte_offs_flag表示2字节；当记录的真实数据大于32767(0x7fff)，此时记录的一部分已经存放到溢出页了，在本页中只保留前768字节和20字节的溢出页面地址，这种情况下使用2个字节来存储每个列对应的偏移量就够了。
- NULL值处理
将列偏移量的第一个比特位作为是否是NULL的依据。该比特位也被称为NULL比特位，如果为1，该列就是NULL，否则就不是NULL。就这是为什么大于127时使用2字节表示一个列对应的偏移量。如果NULL值的列时<font color="red">定长类型</font>，NULL值也将占用记录的真实数据部分例如C3列类型是VARCHAR(10)，1A A4，其对应的偏移量为A4，二进制为1010 0100，1代表NULL值，010 0100转为十进制就是36，1A转为十进制就是26,36-26=10；如果NULL值对应的列是<font color="red">变长类型</font>，则不在记录的真实数据部分占用任何存储空间，例如C4的类型为varchar,列的偏移量1A A4 A4,c4对应的偏移量为A4, A4-A4=0
- CHAR(M)列的存储格式
不管该列使用的字符集是啥，只要使用CHAR(M)类型，该列的真实数据占用的存储空间大小就是该字符集表示一个字符最多需要的字节数和M的乘积，例如CHAR(10),采用的编码是UTF8，则其真实数据占用的字节数就是3*10=30个字节
### 溢出列
![溢出列](溢出列.png)

在Compact和Redundant行格式中，对于占用存储空间非常多的列，在记录的真实数据处理只会存储该列的一部分数据，而把剩余的数据分散存储在几个其他的页中，然后在记录的真实数据处使用20字节存储这些页的地址，从而可以找到剩余数据所在的页。如果需要使用溢出页存储真实数据的列称为溢出列。

页空间的使用：
1. 每个页除了存放记录之外，还要存放一些其他额外的信息，这些信息加起来一共132个字节的空间
2. 每个记录需要的额外信息是27字节，这27个字节包括2个字节用于存储真实数据的长度，1个字节用于存储列是否是NULL值，5字节大小的头信息，6字节的row_id列，6字节的trx_id列，7字节的roll_pointer列。 
3. 存放正常记录的页和溢出页是2种不同类型的页面，对于溢出页来说就没有规定溢出页最少存放2个记录了
<font color="red">MySQL规定一个页中至少存储2行记录</font>。因此如果一个列不发生溢出，就需要满足如下等式：
132+2*(27+n) < 16384(16K)

### DYNAMIC行格式和COMPRESSED行格式
Dynamic行格式和Compressed行格式与Compact行格式很像，只不过在处理溢出列的数据时不同，他们不会在记录的真实数据处存储该溢出列真实数据的前768字节，而是把该列的所有真实数据存储到溢出页中。只在记录的真实数据处存储20字节大小的指向溢出页的地址。Compressed行格式与Dynamic行格式不同的地方在于Compressed行格式会采用压缩算法对页面进行压缩以节省空间。

# InnoDB数据页结构
定义一个概念：数据页，页中存放表中记录的那种类型的页
数据页的默认大小为16KB，可以划分为多个部分，不同部分有不同的功能，每个部分如下：
|名称|中文名|占用空间大小|简单描述
|:--:|:--:|:--:|:--:|
|File Header|文件头部|38字节|页的一些通用信息|
|Page Header|页面头部|56字节|数据页专有的一些信息|
|InFimum+Supremum|页面中最小记录和最大记录|26字节|两个虚拟的记录|
|User Records|用户记录|不确定|用户存储的记录的内容|
|Free Space|空闲空间|不确定|页中尚未使用的空间|
|Page Directory|页目录|不确定|页中某些记录的相对位置|
|File Trailer|文件尾部|8字节|校验页是否完整|

## User Records和Free Space
用户存储的记录会按照指定的行格式存储到User Records中，每当插入一个记录时，都会从Free Space中申请一个记录大小的空间，并将这个空间划分到User Records中。如果Free Space被划分完毕，说明这个页已经用完了，需要去重新申请一个新的页了。另外各记录在按照行格式存储到User Records中没有空隙的，如下图所示：
![记录在页的UserRecords的存储结构](记录在页的UserRecords的存储结构.png)

从图中可以看出，被删除的记录还是会存在页中的，只是删除标记置位1了，之所以这样做是因为，移除他们之后，还需要在磁盘上重排列，非常消耗性能。所有被删除的记录会组成一个垃圾链表，记录在这个链表中占用的空间叫做可重用空间，如果有新的记录插入到表中，它们可能会覆盖这些记录所占用的可重用空间。

next_record：
![使用箭头代替next_record的值](使用箭头代替next_record的值.png)

记录按照主键从小到大形成了一个单向链表。Suprememum的next_record的值为0，说明suprememum后面没有记录了。

<font color="red">
next_record的值指向记录头信息和真实数据之间的位置：<br>
这个位置刚刚好向左就是记录头信息，向右就是真实数据，这就是为什么之前可变字段长度列表和NULL值列表中的信息都是逆序的原因。
</font>

删除第2条记录的操作(单链表删除节点的操作)：
1. 第2条记录并没有从存储空间移除，而是将其deleted_flag置为1
2. 将该记录的next_record置为0，意味着没有下一条记录了，将其移除到垃圾链表
3. 第一条记录的next_record指向第三条记录
4. supremum记录的n_owned的值从5变为4

## Finfimum和Supremum
继续如图所示：
![记录在页的UserRecords的存储结构](记录在页的UserRecords的存储结构.png)
heap_no不为0和1的原因是MySQL自动给页加了2个记录，这2条记录不是用户插入的，所以也叫伪记录或者虚拟记录。这2条记录分别表示页面中的最小记录(Infimum记录)和页面中的最大记录(Supremum记录)。heap_no的值与主键大小有关，主键小的在前面，主键大的在后面。

## Page Directory
根据主键查找页中记录，如上图简单想法是单链表从头一直查到第一个主键比需要查找主键的值大的位置，这种方式性能太差，MySQL是如下操作：
1. 将所有的正常记录(包括Infimum和Supremum记录，但不包括移除到垃圾链表的记录)划分为几个组
2. 每个组的最后一条记录相当于带头大哥，该记录的记录头信息中的o_owned的值就表示该组中有几条记录
3. 每个组的最后一条记录在页面中的地址偏移量单独提出出来，按照顺序存储到靠近页尾的地方，这个地方就是Page Directory，Page Director中的这些地址偏移量称为槽，一个正常的页面大小是16384，因此2个字节可以表示的范围是65535，因此每个槽占用2个字节

如下图表示记录和Page Director的关系：
![记录和PageDirectory的关系](记录和PageDirectory的关系.png)

分组的方式按照如下步骤：
1. 初试情况，Infimum和Supremum2条记录分为2个组，o_owned的值都为1
2. 插入一条记录时，从Page Directory中找到对应记录的主键值比待插入记录的主键值大并且差值最小的槽，，然后把该槽的o_owned的值+1，直到该组的记录数为8
3. 当一个组的数量达到8时，这时在插入一条记录时，会将组中的记录差分成2个组，一个组的记录是4，另一个组的记录数是8，当然拆分的过程会增加一个槽

假设已有的记录在如下图所示，要查找主键值为6的记录：
![页中记录](页中记录.png)

1. 计算中间槽的位置，(0+4)/2 = 2，槽2对应的主键值为8，8 >6，令low不变，high = 2
2. 重新计算中间槽的位置，(2+2)/2 = 1，槽1对应的主键值为4， 4 < 6，所以令low = 1， high = 1
3. high - low = 1，所以要找的记录在槽2对应的组中，槽是相邻的，从槽1对应的记录出发，找到下一条记录6

综上所述：查找记录指定主键值的记录分为2步
1. 通过2分法查找到对应的槽，然后根据该槽的上一个相邻槽找到该槽的最小记录
2. 通过步骤1的记录遍历该组的记录

## Page Header
比如数据页中有多少条记录？Free Space的地址偏移量，页目录中有多少个槽，在数据页中定义了一个名为Page Header的部分。它是页结构的第二部分，占用固定的56字节，专门存储各种状态信息。Page Header各个字节的具体用图如下所示：
|状态名称|占用空间大小|描述|
|:--:|:--:|:--:|
|PAGE_N_DIR_SLOTS|2字节|在页目录中的槽数量|
|PAGE_HEAP_TOP|2字节|还未使用的空间最小地址，从该地址之后就是Free Space|
|PAGE_N_HEAP|2字节|第1个比特位表示被记录是否为紧凑型的记录，其余15为表示本页含有的记录数(包括Infimum、Supremum和标记为删除的记录数)
|PAGE_FREE|2字节|各个被标记为已删除的记录组成的垃圾链表头结点的地址偏移量|
|PAGE_GARBAGE|2字节|已删除记录占用的字节数|
|PAGE_LAST_INSERT|2字节|最后插入记录的位置|
|PAGE_DIRECTION|2字节|记录插入的方向|
|PAGE_N_DIRECTION|2字节|一个方向连续插入的记录数量|
|PAGE_N_RECS|2字节|该页中的记录数(不包括Infimum、Supremum和标记为删除的记录)|
|PAGE_MAX_TRX_ID|8字节|修改当前页的最大事务id，该值仅在二级索引页面中定义|
|PAGE_LEVEL|2字节|当前页在B+数中所处的层级|
|PAGE_INDEX_ID|8字节|索引ID，表示当前页属于哪个索引|
|PAGE_BTR_SEG_LEAF|10字节|B+树叶子节点段的头部信息，仅在B+树的根页面中定义|
|PAGE_BTR_SET_TOP|10字节|B+树非叶子节点段的头部信息，仅在B+树的根页面中定义|

- PAGE_DIRECTION: 加入新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，否则就是左边，该状态信息表示最后一条记录插入的方向
- PAGE_N_DIRECTION:假设连续几条插入的方式都是一致的，InnoDB会把验证同一个方向的记录数记录下来，用该状态表示，如果最后一条记录的插入方向方式了改变，该状态就会清0重置

## File Header
各个类型页都会以File Header作为页结构的第一部分，它描述了页的一些通用信息，比如页的编号，它的上一个页和下一个页是什么等等。它占用固定的38个字节，各个字节的具体用途如下：

|状态名称|占用空间大小|描述|
|:--:|:--:|:--:|
|FIL_PAGE_SPACE_OR_CHKSUM|4字节|MySQL版本低于4.0.14，其表示本页面所在的表空间id，之后的版本表示页的校验和|
|FIL_PAGE_OFFSET|4字节|页号|
|FIL_PAGE_PREV|4字节|上一个页的页号|
|FIL_PAGE_NEXT|4字节|下一个页的页号|
|FIL_PAGE_LSN|8字节|页面被最后修改时对应的LSN(Log Sequence Number，日志序列号)值|
|FIL_PAGE_TYPE|2字节|该页的类型|
|FIL_PAGE_FILE_FLUSH_LSN|8字节|仅在系统表空间的第一个页中定义，代表文件至少被刷新到了对应的LSN值|
|FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID|4字节|页属于哪个表空间|

其中FILE_PAGE_TYPE(其他类型的页)的值如下所示：
|类型名称|十六进制|描述|
|:--:|:--:|:--:|
|FIL_PAGE_TYPE_ALLOCATED|0X0000|最新分配，还未使用|
|FIL_PAGE_UNDO_LOG|0X0002|undo日志页|
|FIL_PAGE_INODE|0X0003|存储段的信息|
|FIL_PAGE_IBUF_FREE_LIST|0X0004|Change Buffer空闲列表|
|FIL_PAGE_IBUF_BITMAP|0X0005|Change Buffer的一些属性|
|FIL_PAGE_TYPE_SYS|0X0006|存储一些系统数据|
|FIL_PAGE_TYPE_TRX_SYS|0X0007|事务系统数据|
|FIL_PAGE_TYPE_FSP_HDR|0X0008|表空间头部信息|
|FIL_PAGE_TYPE_XDES|0X0009|存储区的一些属性|
|FIL_PAGE_TYPE_BLOB|0X000A|溢出页|
|FIL_PAGE_INDEX|0X45BF|索引页，也就是我们所说的数据页|

## File Trailer
如果某个数据页的内存被修改了，在修改后的某个时间刷新到磁盘中，在刷新还没有完成的时候，断电了，File Trailer用于校验一个页是否完整(也就是刷新时只刷新了一部分的尴尬情况)。该部分由8个字节组成，分成2部分
- 前4字节代表页的校验和，在刷新前将页面的校验和算出来，因为File Header在页的前面，所以File Header中的校验和会首先刷新到磁盘，当完全写入之后，校验和也会被写到File Trailer，在刷入磁盘。如果页面刷新成功，则页首和页尾的校验和是一致的，如果刷新了一半断电了，那么File Header是修改后的校验和，而File Trailer是修改前的校验和，俩者不同意味着刷新期间发生了错误
- 后4字节袋面页面被最后修改时对应的LSN的后4字节，正常情况应该与File Header头部的FIL_PAGE_LSN的后4字节相同，这个部分也是用于校验页的完整性。如果页首和页尾不一致，也是意味着刷新期间发生了错误

# 快速查询的索引——B+树
每个数据页都会为存储在它里面的记录生成一个页目录，在通过主键查询某条记录的时候可以在页目录中使用二分法快速定位到槽，然后在遍历该槽对应分组中的记录即可快速找到指定的记录

## 建立索引的语句
1. 第一种
```mysql
CREATE TABLE 表名 {
    各个列的信息...
    (KEY|INDEX) 索引名 (需要被索引的单个列或多个列)
}
```
其中key和INDEX是同义词，任选一个即可。

2. 第二种
```mysql
ALTER TABLE 表名 ADD (KEY|INDEX) 索引名 (需要被索引的单个列或多个列)
```

3. 删除索引
```mysql
ALATER TABLE 表名 DROP (KEY|INDEX) 索引名
```


## 一个简单的索引方案
为快速定位记录所在的数据页建立一个别的目录(该目录就是索引)，建立这个目录需要完成2件事：
1. 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值
2. 给所有的页建立一个目录项
![为页编制目录](为页编制目录.png)
当我们想要查找主键值为20的记录在目录项中(因为12<20<209)，对应的页是9，再根据在页中查找记录的方式去页9中定位具体的记录

这样做有几个问题：
1. InnoDB使用页作为管理存储空间的基本单位，也就是最多保证16KB的连续存储空间，如果表中的记录非常多，此时需要非常大的且连续的存储空间才能将所有的目录项都放下。
2. 时常有对记录有增加改的操作，假设把28页的记录都删除，则目录项2就没有必要了，因此目录项2后面所有的目录项都得向前移动。假设不移动目录项2，而是将其作为冗余放在目录项中，又浪费了存储空间。

## InnoDB的索引方案
设计师发现目录项其实与用户记录很像，只不过目录项中的2个列时主键和页号而已，所以可以复用用户记录的数据页来存储目录项，为了与用户记录区分，我们把这些用来表示目录项的记录称为目录项记录——根据record_type属性。它的取值代表的意思是：0——普通的用户记录；1——目录项记录；2——Infimum记录；3——Supremum记录

将目录项放到数据页的效果如下：
![将目录项放到数据页的效果](将目录项放到数据页的效果.png)

注意：
1. 目录项记录的record_type的值为1，普通用户记录的record_type的值为0
2. 目录项纪录只有主键值和页的编号俩个列，而普通用户记录的列时用户自定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列
3. 目录项纪录的min_rec_flag的属性值为1，普通用户记录的min_rec_flag属性都是0

以查找主键值为20的记录为例：
1. 先到存储目录项纪录页(也就是页30)中铜鼓哦二分法快速定位到对应的目录项记录，12<20<209，所以定位到对应的用户记录所在的页就是页9
2. 再到存储用户记录的页9中根据二分法快速定位到主键值为20的用户记录

我们可能需要定位存储目录项记录的页，但是这些页在存储空间中也可能不挨着。如果表中的数据很多，则会产生很多存储目录项记录的页，那如何根据主键值快速定位一个存储目录项记录的页呢？为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，各个页的示意图如下：
![生成更高高级目录项记录的数据页](生成更高高级目录项记录的数据页.png)
上图中升级了一个存储更高级目录项记录的页33。这个页中的两条记录分别代表页30和页32。

无论是存放用户记录的数据页还是存放目录项记录的数据页，我们都把它存放到B+树这个数据结构中。我们也将这些数据页成为B+树的节点。从上图中可以看出，真正的用户记录其实都存放在叶子节点。其余用来存放目录项纪录的节点成为非叶子节点或者内节点，其中B+树最上层的节点也成为根节点。

### 聚簇索引
1. 使用记录主键值的大小进行记录和页的排序，这包括三层含义
    1.1 页(包括叶子节点和内节点)内的记录按照主键的大小排序排成衣蛾单向链表，业内的记录被划分成若干个组，每个组中主键值最大的记录在页内的偏移量会被当做槽一次存放在页目录中
    1.2 各个存放用户记录的页也就是根据页中用户记录的主键大小排除排成一个双向链表。
    1.3 存放目录项记录的页分为不同的层级，在同一层级中的页也就是根据页中目录项记录的主键大小顺序排成一个双向链表
2. B+树的叶子节点存储的是完整的用户记录。所谓的完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)

有时候会以别的列例如C2列作为搜索条件该咋办？可以多建几颗B+树。
### 二级索引
1. 使用C2列的大小进行记录和页的排序，这包括三层含义
    1.1 页(包括叶子节点和内节点)内的记录是按照C2列的大小顺序排成一个单向链表，页内的记录被划分出若干个组，每个组中C2列值最大的记录在页内的偏移量会被当做槽一次存放在页目录中
    1.2 各个存放用户记录的页就是根据页中记录的C2列大小顺序排成一个双向链表
    1.3 存放目录项记录的页分为不同层级，在同一层级中的页就是根据页中目录项记录的C2列大小顺序排成一个双向链表
2. B+树的叶子节点存储的并不是完整的用户记录，而只是C2列+主键这两个列的值。
3. 目录项纪录中不再是主键+页号的搭配，而变成了C2列+页号的搭配。

假设想查找满足C2 = 4的记录，就可以使用刚刚建好的这颗B+树，因为C2列并没有唯一属性，因此满足搜索条件的记录可能有多个，只需要在该B+树叶子节点定位到第一条满足搜索条件C2=4的那条记录，然后沿着由记录组成的单向链表一直向后扫描即可。另外，各个叶子节点组成了双向链表，搜索完了本页面的记录后可以很顺利的跳到下一个页面的第一条记录。然后沿着记录组成的单向链表继续向后搜索，查找过程如下：

1. 确定第一条符合C2=4条件的目录项记录所在页
2. 通过第一条符合C2=4条件的目录相机所在的页确定第一条符合C2=4条件的用户记录所在的页
3. 在真正存储第一条符合C2=4条件的用户记录的页中定位到具体的记录
4. 这个B+树的叶子节点中的记录只存储了C2和C1(也就是主键)两个列。在这个B+树的叶子节点处定位到第一条符合条件的那条用户记录之后，需要根据该记录中的主键信息到聚簇索引中查找到完成的记录，这个通过携带主键信息到聚簇索引重新定位完整的用户记录的过程也成为回表。然后在回到符合条件的叶子节点处继续向后搜索查找所有符合条件的记录。

### 联合索引
我们也可以同时以多个列的大小作为排除的规则，也就是同时为多个列建立索引。例如我们想让B+树按照C2和C3的大小进行排序，这里面包含2层含义：
1. 先把各个记录和页按照C2列进行排序
2. 在记录的C2列相同的情况下，在采用C3列进行排序
![联合索引示意图](联合索引示意图.png)
注意：
1. 每条目录项记录都有C2列、C3列、页号组成。格条记录先按照C2列的值进行排序，如果记录的C2列相同，则按照C3列的值进行排序
2. B+树叶子节点处的用户记录有C2列、C3列和主键C1列组成

以C2和C3列的大小排序规则建立的B+树称为联合索引，也称为复合索引或多列索引。它本质上是一个二级索引，它的索引包括C2和C3，<font color="red">以C2和C3列的大小为排序规则建立联合索引</font>和<font color="red">分别以C2和C3列建立索引</font>的表述是不同的。不同点如下：
1. 建立联合索引只会建立如上图一颗B+树
2. 为C2和C3列分别建立索引时，则会分别以C2和C3列的大小为排序规则建立两颗B+树

### InnoDB中B+树索引的注意事项
1. 根页面万年不动
2. 内节点中目录项记录的唯一性：为了让新插入的记录能找到自己在哪个页中，就需要保证B+树同一层内节点的目录项纪录除页号这个字段以外是唯一的。所以二级索引的内节点的目录项记录的内容实际上是由3部分构成的1. 索引列的值；2. 主键的值；3. 页号。
3. 一个页面至少容纳2条记录：如果一个大的目录中只存放一个子目录会导致目录层级非常多，到最后只存放一条真正的记录，所以一个页面至少容纳2条记录是为了防止B+树的层级增长的过高

## MyISAM的索引方案
MyISAM的索引方案虽然也使用树形结构，但是却将索引和数据分开存储。，将表中的记录按照记录的插入顺序单独存储在一个文件中(称之为数据文件)。这个文件并不划分为若干个数据页，有多少条记录就往这个文件中塞多少条记录，这样一来就可以通过行号快速访问到一条记录。MyISAM记录也需要记录头信息来存储一些额外的数据，下图所示为一张表的记录如何在存储空间中表示：
![使用MyISAM作为存储引擎在存储空间中的表示](使用MyISAM作为存储引擎在存储空间中的表示.png)
由于在插入数据时并没有可以按照主键大小排序，所以我们不能再这些数据上使用二分法进行查找。

- 使用MyISAM存储引擎会把索引信息单独存储到另外一个文件中(称之为索引文件)。MyISAM会为表的主键单独创建一个索引，只不过在索引的叶子节点中存储的不是完成的用户记录，而是主键值与行号的组合，也就是先通过索引找到对应的行号，再通过行号去找对应的记录。(InnoDB存储引擎中，根据主键值对聚簇索引进行一次查找就能找到对应的记录，在MyISAM却需要进行一次回表操作)
- 如果有必要，也可以为其他列分别建立索引或者建立联合索引，其原理与InnoDB中的索引差不多，只不过在叶子节点处存储的是相应的列+行号。这些索引也全部是二级索引。

# 数据的家——MySQL的数据目录
## 数据目录
```mysql
SHOW VARIABLES LIKE 'datadir'
```

## 数据库在文件系统中的表示
每当使用'CREATE DATABASE 数据库名'创建一个数据库时，每个数据库都对应数据目录下的一个子目录。当我们创建一个数据库时，MySQL会帮我们做两件事：
1. 在数据目录下创建一个与数据库同名的子目录(或者说文件夹)
2. 在与该数据库名同名的子目录下创建一个名为db.opt的文件。这个文件中包含了该数据库的一些属性，比如该数据库的字符集和比较规则。

<font color="red">information_schema比较特殊，没有在数据目录下为其创建子目录</font>

## 表在文件系统中的表示
我们的数据都是以记录的形式插入到表中的，表的信息可以表示为两种：
1. 表结构的定义
2. 表中的数据

表结构的定义指的是该表的名称是啥，表里面有多少列，每个列的数据类型是啥，有啥约束条件和索引，用的是啥字符集和比较规则等各种信息。为了保存这些信息，InnoDB和MyISAM这俩种存储引擎都在数据目录下对应的数据库子目录中创建了一个专门用于描述表结构的文件，文件名是<font color="red">表名.frm</font>

表中的数据存储不同的存储引擎有不同的处理方式：
### InnoDB
InnoDB使用页为基本单位管理存储空间的，默认的页的大小为16KB。每个索引对应着B+树，该B+树的每个节点是一个数据页，数据页之间不一定是连续的。InnoDB的聚簇索引的叶子节点存储了完整的用户记录，也就是所谓的“索引即数据，数据即索引”。
为了更好的管理这些页，MySQL提出了表空间或者文件空间的概念。这个表空间是一个抽象的概念，他可以对应文件系统上一个或多个真实的文件(不同表空间对应的文件数量可以不一样)，每一个表空间可以被划分为很多个页，表数据就存放在某个表空间下的某些页中。InnoDB将表空间划分成了几种不同的类型
1. 系统表空间：默认情况下，InnoDB会在数据目录下创建一个命难为ibdata1，大小为12MB的文件，这个文件就是对应系统表空间在文件系统上的表示。也可以通过在mysql的配置文件中配置对应的文件名称、路径以及大小，例如：
```shell
[server]
innodb_data_file_path=data1:512M;data2:512M:autoextend
```
其中，autoextend表明如果这2个文件不够用，会自动扩展data2文件的大小，<font color="red">在一个MySQL中，系统表空间只有一份</font>
2. 独立表空间：在5.6版本之后，系统不在把各个表的数据存储到系统表空间，而是为每一个表建立一个独立表空间。在使用独立表空间存储表数据时，会在该表属于数据库对应的子目录下创建一个表示该独立表空间的文件，<font color="red">文件名是表名.ibd</font>。值得注意的是：我们也可以自己指定使用系统表空间还是独立表空间来存储数据，这个功能由启动选项innodb_file_per_table控制，如果值为0，表示使用系统表空间，如果值为1，表示使用独立表空间。不过innodb_file_per_table只对新建的表起作用。想把已经存储到系统表空间的表转移到独立表空间，语法：ALTER TABLE 表名 TABLESPACE [=] innodb_file_per_table；想把已经存储到独立表空间的表转移到系统表空间，语法：ALTER TABLE TABLESPACE [=] innodb_system。中括号中的"="号可以可无
3. 其他类型的表空间
除了上述2种表空间之外，还有一些不同类型的表空间，比如通用表空间，undo表空间，临时表空间等。。。

### MyISAM
MyISAM中的索引相当于全部都是二级索引，数据和索引是分开存储的。所以文件系统中也是使用不同的文件来存储数据文件和索引文件。与InnoDB不同的点是MyISAM并没有表空间一说，表的数据和索引都存放到对应的数据库子目录下。假设有一个数据库，在其中创建一个test的表，该数据库对应的子目录下有以下三个文件：test.frm;test.MYD;test.MYI。其中test.MYD表示表的数据文件，也就是插入的用户记录；test.MYI表示表的索引文件。

## 其他的文件
除了上面说的用户自己存储的数据外，数据目录下还包含了一些确保程序更好运行的额外文件，主要包括下面几种类型：
1. 服务器进程文件：每运行一个MySQL服务器程序，都意味着启动一个进程，MySQL都会把自己的进程ID写入这个文件中
2. 服务器日志文件：在服务器运行期间，会产生各种各样的日志，比如常规的查询日志，错误日志，二进制日志，redo日志等。
3. SSL和RSA证书与密钥文件：主要是为了客户端与服务器安全通信而创建的一些文件。

## 文件系统对数据库的影响
因为MySQL的数据都是存储在文件系统中，因此会受到一些文件系统的制约，主要体现在一下几类方面：
1. 数据库名称不能超过文件系统所允许的最大长度。
2. 特殊字符的问题：为了避免因为数据库名和表名出现某些特殊字符而造成文件系统不支持的情况，MySQL会把数据库名和表名中所有除数字和拉丁字母意外的任何字符在文件名中都映射成@+编码值的形式，并将其作为文件名
3. 文件长度受文件系统最大长度的限制。

## MySQL系统数据库的简介
- mysql：存储了MySQL的用户账户和权限的信息、一些存储过程和事件的定义信息、一些运行过程中产生的日志信息、一些帮助以及失去信息等。
- information_schema: 存储了MySQL服务器维护的所有其他数据库的信息，比如哪些表、哪些视图、哪些触发器、哪些列、哪些索引等，这些信息不是真实的用户数据，而是一些描述信息，有时候也称之为元数据。
- performance_schema: 存储了服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。它包含的信息有统计最近执行了哪些语句，在执行过程中的每个阶段都花费了多长时间，内存的使用情况等。
- sys: 这个数据库主要是通过视图的形式把information_schema和performance_schema结合起来，让开发人员更方便的了解MySQL服务器的性能信息。

# 存放页面的大池子
表空间是一个抽象的概念：对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着一个名为"表名.ibd"的实际文件。

|类型名称|16进制|描述|
|:--:|:--:|:--:|
|FIL_PAGE_TYPE_ALLOCATED|0x0000|最新分配，还未使用|
|FIL_PAGE_UNDO_LOG|0x0002|undo日志页|
|FIL_PAGE_INODE|0x0003|存储段的信息|
|FIL_PAGE_IBUF_FREE_LIST|0x0004|Change Buffer空闲列表|
|FIL_PAGE_IBUF_BITMAP|0x0005|Change Buffer的一些属性|
|FIL_PAGE_TYPE_SYS|0x0006|存储一些系统数据|
|FIL_PAGE_TYPE_TRX_SYS|0x0007|事务系统数据|
|FIL_PAGE_TYPE_FSP_HDR|0x0008|表空间头部信息|
|FIL_PAGE_TYPE_XDES|0x0009|存储区的一些属性|
|FIL_PAGE_TYPE_BLOB|0x000a|溢出页|
|FIL_PAGE_INDEX|0x45BF|索引页，也就是我们所说的数据页|

所有页的类型都会包含2个部分：
1. file header：记录页面的一些通用信息
2. file trailer： 校验页是否完整，保证页面从内存刷新到磁盘后内容是相同的

在file header中需要注意的是：
- 表空间中的每一个页都对应着一个页号，也就是FIL_PAGE_OFFSET，可以通过这个页号在表空间快速定位到指定的页面，这个页号由4字节组成，也就是32位，，所以一个表空间最多可以拥有2^32个页，每个页的默认大小为16KB，即一个表空间最多支持64TB的数据。
- 某些类型的页可以组成链表，链表中相邻的两个页面的页号可以不连续，即它们可以不按照在表空间中的物理位置相邻存储，而是根据FIL_PAGE_PREV和FIL_PAGE_NEXT来存储上一个页和下一个页的页号。需要注意的是一般是INDEX类型的页面使用这两个字段，其他的页面类型不使用这两个字段。
- 每个页的类型由FIL_PAGE_TYPE表示。具体的在上表中。

## 独立表空间结构
### 区的概念
对于16KB的页来说，连续的64个页就是一个区，也就是说一个区默认占用1MB空间大小。无论是系统表空间还是独立表空间，都可以看成是由若干个连续的区组成的，每256个区被划分成一组，如下图所示：
![每个组的页面类型](每个组的页面类型.png)
从图中可以看出：
1. 第一个组的最开始的3个页面的类型都是固定的。
    - FSP_HDR: 这个类型的页面用来登记整个表空间的一些整体属性以及本组所有的区的属性，需要注意的是，整个表空间只有一个FSP_HDR类型的页面
    - IBUF_BITMAP: 这个类型的页面用来存储关于Change Buffer的一些信息。
    - INODE: 这个类型的页面存储了许多成为INODE Entry的数据结构。
2. 其余各组最开始的2个页面的类型是固定的
    - XDES: 全称是extent descriptor，用来登记本组256个区的属性。FSP_HDR与XDES类型的页面相似，只是FSP_HDR还会额外存储一些表空间的属性
    - IBUF_BITMAP: 这个类型的页面用来存储关于Change buffer的一些信息。

总的来说每个区由64个页组成、每256个区组成一组、每个组的开始的几个页面的类型是固定的。

### 段的概念
不引入区的概念，只使用页的概念对存储引擎的运行并没有影响，但是如果考虑到这样一个场景：向表中插入一条记录，实际上就是向该表的聚簇索引和二级索引代表的B+树的节点插入数据。而B+树每一层中的页都会形成一个双向链表，如果以页为单位来分配存储空间，双向链表相邻的两个页之间的物理位置可能离的非常远，对于传统机械硬盘来说，需要重新定位磁头的位置，也就是会产生随机I/O，这样影响磁盘的性能。所以应该尽量让页面链表相邻的页的物理位置页相邻，这样在扫描叶子节点中大量记录的时才可以使用顺序I/O。(不连续也可以，无非就是性能差一点)

因此引入了区的概念，一个区就是物理位置上连续的64个页，且区里的页号也都是连续的，在表中的数据量很大时，为某个索引分配空间的时候就不再按照页为单位进行分配，而是直接按照区来分配。虽然会造成存储空间的浪费，但是性能提升了很多。

如果执行查询时扫描叶子结点的记录而不区分叶子节点和非叶子节点，统统把节点代表的页申请到区中，扫描效果还是会打折扣，因此对B+树的叶子节点和非叶子节点进行了区别的对待即叶子节点和非叶子节点都有各自独立的区。存放叶子节点的区就算是一个段，而存放非叶子节点的区是另外一个段。一个索引会产生2个段：一个叶子节点段和一个非叶子节点段

在考虑这样一个场景：默认情况下一个只存放了几条记录的小表也需要申请2MB(段以区为单位申请，每个区默认大小为1MB，一个叶子节点段，一个飞叶子节点段)？这个问题在于一个区被整个分配给某个段(区中的所有页面都是为了存储同一个段的数据，即使段的数据填不满区中所有的页面，剩下的页面也不能挪作他用)。引入一个碎片区的概念：在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，碎片区中的页可以用作不同的目的，比如有些页属于段A，有些页属于段B，有些页不属于任何段。碎片区直属于表空间，因此为某个段分配存储空间的策略如下：
1. 刚开始向表中插入数据时，段是从某个碎片区以单个页面为单位来分配存储空间
2. 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间(原先占用的碎片区页面并不会被废止到新申请的完整的区中)

段不仅能定义某些区的集合，更精确的来说：应该是某些零散的页面以及一些完整区的集合。除了索引的叶子节点和非叶子节点的段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段

## 区的分类
表空间是由若干个区组成，这些区大致分为4中类型：
- 空闲的区： 现在还没有用到这个区中的任何页面
- 有剩余空闲页面的碎片区： 表示碎片区中还有可被分配的空闲页面
- 没有升级空闲页面的碎片区： 表示碎片区中的所有页面都被分配使用，没有空闲页面
- 附属于某个段的区： 每一个索引都可以分为叶子页面和非叶子节点段。除此之外，InnoDB还会定义一些特殊用途的段。当这些段中的数据量很大时，将使用区作为基本的分配单位，这些区中的页面完全用于存储该段中的数据

|状态名|含义|
|:--:|:--:|
|FREE|空闲的区|
|FREE_FRAG|有剩余空闲页面的碎片区|
|FULL_FRAG|没有剩余空闲页面的碎片区|
|FSEG|附属于某个段的区|
值得一提的是FREE、FREE_FRAG、FULL_FRAG直属于表空间，而FSET附属于某个段。有一个数据结构XDES Entry(Extent Descriptor Entry)可以方便的管理这些区，每个区都对应着一个XDES Entry的结构这个结构记录了对应的区的一些属性。
![XDES_Entry结构示意图](XDES_Entry结构示意图.png)

- Segment ID: 每个段都有一个独立的编号，用ID表示。Segment ID字段表示的就是该区所在的段，前提是该区已经被分配给某个段了，不然没有意义
- ListNode： 这个部分可以将若干个XDES Entry结构串成一个链表。
- State: 这个字段表明区的状态。可选值为FREE、FREE_FRAG、FULL_FRAG以及FSEG。
- Page State Bitmap: 这个部分共16字节，也就是128位。一个区默认有64个页，因此每2个比特位对应着区中的一个页。这2位中的第一位表示该页是否空闲，第二位暂时没用到。

### XDES Entry链表
向某个段中插入数据申请新页面的过程：当段中的数据较少时，首先会查看表空间中是否有FREE_FRAG的区，如果找到了，那么就从该区中去一个零散的页面插进去；否则到表空间中申请一个FREE的区，把该区的状态变为FREE_FRAG，然后从该新申请的区中去一个零散页把数据插入进去；之后在不同的段使用零散页的时候都从该区中取，知道该区中没有空闲页面，然后该区的状态就变为了FULL_FRAG的状态。

那么怎么知道哪些区是FREE，哪些区是FREE_FRAG的呢？这就用到了XDES Entry中ListNode结构了：
1. 通过List Node把状态为FREE的区对应的XDES Entry结构连成一个链表，这个链表成为FREE链表
2. 通过List Node把状态为FREE_FRAG的区对应的XDES Entry结构连成一个链表，这个链表称为FREE_FRAG链表
3. 通过List Node把状态为FULL_FRAG的区对应的XDES Entry结构连成一个链表，这个链表称为FULL_FRAG链表

这样每当想查找一个FREE_FRAG状态的区时，就直接把FREE_FRAG链表的头结点拿出来，从这个节点队对应的区中取一些零散页来插入数据。当这个节点对应的区中没有零散页时，就修改它的State字段的值，并将其从FREE_FRAG链表移入FULL_FRAG链表；同理当FREE_FRAG链表中一个节点都没有，那么就直接从FREE链表中去一个节点移动到FREE_FRAG链表，并修改其State字段的值，然后从这个节点对应的区中取一些零散页。当段中的数据占满32个零散页后，就申请完整的区来插入数据。

怎么知道哪些区属于哪个段呢？为每个段中的XDES Entry结构建立3个链表：
1. FREE链表：同一个段中，所有页面都是空闲页面的区对应的XDES Entry结构会被加入到这个链表中，这与上面的FREE链表不是一回事。
2. NOT_FULL链表：同一个段中，仍有空闲页面的区对应的XDES Entry结构会被加入到这个链表中。
3. FULL链表：同一个段中，已经没有空闲页面的区对应的XDES Entry结构会被加入到这个链表中。

每个索引都有2个段，每个段都会维护上述3个链表。

### 举例
```shell
CREATE TABLE t (
    c1 INT NOT NULL,AUTO_INCREMENT,
    c2 VARCHAR(100),
    c3 VARCHAR(100),
    PRIMARY KEY(c1),
    KEY idx_c2(c2)
)ENGINE=InnoDB
```
表中共有2个索引，一个聚簇索引和一个二级索引idx_c2。所以这个表共有4个段，每个段都会维护FREE链表、NOT_FULL链表以及FULL链表，总共是12个链表。以及直属于表空间的FREE链表、FREE_FRAG链表以及FULL_FRAG链表，整个独立表空间共需要维护15个链表。

### 链表基节点
如何找到上述的这些链表或者说怎么找到某个链表的头结点呢？有一个名为List Base Node(链表基节点)的结构。这个结构包含了链表的头结点和尾结点的指针以及这个链表中包含了多少个节点的信息，如图所示：
![ListBaseNode](ListBaseNode.png)
- List length: 该链表有多少个节点
- First Node Page Number和First Node Offset：该链表的头结点在表空间的位置
- Last Node Page Number和Last Node Offset: 该链表的尾结点在表空间的位置

一般将某个链表对应的List Base Node放到表空间的固定位置，这样就可以很容易的定位某个链表了

### 链表小结
表空间是由若干个区组成的，每个区都对应着一个XDES Entry结构。只属于表空间的区对应的XDES Entry结构可以分成FREE、FREE_FRAG和FULL_FRAG链表。每个段可以拥有若干个区，每个段中的区对应的XDES Entry可以构成FREE、NOT_NULL和FULL这三个链表。每个链表都对应着一个List Base Node结构，这个结构中记录了链表头结点、尾结点以及该链表包含结点的个数的信息。

## 段的结构
段不对应表空间某个连续的物理存储空间，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。像每个区对应着一个XDES Entry结构一样，每个段对应着一个INODE Entry结构。
![INODE_Entry](INODE_Entry.png)
INODE Entry结构中各个部分的含义如下：
- Segment ID: 这个INODE Entry结构对应的段的编号
- NOT_FULL_N_USED: 在NOT_FULL链表中已经使用了多少个页面
- 3个List Base Node： 分别为段的FREE、NOT_FULL、FULL链表定义的List Base Node，这样当想查找某个段的某个链表的头结点和尾结点时，可以直接到这个部分找到对应链表的List Base Node。
- Magic Number: 标记INODE Entry是否已经被初始化。如果这个数字的值为97937874，表明该INODE Entry已经被初始化。这个数字没有特殊的含义，仅仅是人为规定
- Fragment Array Entry: 段是一些零散页面和一些完整的区组成，每个Fragment Array Entry对应着一个零散的页面，表示一个零散页面的页号

## 各类型页面详细情况
### FSP_HDR类型
这是第一个组的第一个页面，页号为0，也是表空间的第一个页面，它存储了表空间的一些整体属性以及第一个组内256个区对应的XDES Entry结构，如下图所示：
![FSP_HDR类型的页结构示意图](FSP_HDR类型的页结构示意图.png)

|名称|中文名|占用空间大小|简单描述|
|:--:|:--:|:--:|:--:|
|File Header|文件头部|38|页的一些通用信息|
|File Space Header|表空间头部|112|表空间的一些整体属性信息|
|XDES Entry|区描述信息|10240|存储本组256个区对应的属性信息|
|Empty Space|尚未使用空间|5986|用于页结构的填充，没啥实际意义|
|File Trailer|文件尾部|8|校验页是否完整|

#### File Space Header
![File_Space_Header](File_Space_Header.png)
|名称|占用空间大小|描述|
|:--:|:--:|:--:|
|Space ID|4|表空间ID|
|Not Used|4|未被使用，可以忽略|
|Size|4|当前表空间拥有的页面数|
|FREE Limit|4|尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入到FREE链表|
|Space Flags|4|表空间的一些占用存储空间比较小的属性|
|FRAG_N_USED|4|FREE_FRAG链表中已使用的页面数量|
|List Base Node for FREE List|16|FREE链表的基节点|
|List Base Node for FREE_FRAG List|16|FREE_FRAG链表的基节点|
|List Base Node for FULL_FRAG List|16|FULL_FRAG链表的基节点|
|Next Unused Segment ID|8|当前表空间中下一个未使用的Segment ID|
|List Base Node for SEG_INODES_FULL List|16|SEG_INODES_FULL链表的基节点|
|List Base Node for SEG_INODES_FREE_List|16|SEG_INODES_FREE链表的基节点|

- List Base Node for FREE List、List Base Node for FREE_FRAG List、List Base Node for FULL_FRAG List: 直属于表空间的FULL、FREE_FRAG、FULL_FRAG链表的基节点，这三个链表的基节点在File Space Header部分中的位置是固定的。
- FRAG_N_USED: 表明在FREE_FRAG链表中已经使用的页面数量
- FREE Limit: 表空间对应着具体的磁盘文件，表空间在最初创建时会有一个默认的大小。且磁盘文件是一个自增长文件，当文件不够用时，会自动增加文件大小。这会带来2个问题：
    1. 最初创建一个表空间时，可以指定一个非常大的磁盘文件，接着对表空间完成一个初始化的操作：包括为表空间中的区建立对应的XDES Entry结构；为各个段建立对应的INODE Entry结构；建立各个链表等。但是对于非常大的磁盘文件来说，有很多存储空间是空闲的。因此：可以把所有的空闲区加入到FREE链表、也可以把一部分空闲区加入到FREE链表，等FREE链表不够用时，再把空闲的区对应的XDES Entry加入到FREE链表。
    2. 对于自增加的存储文件来说，可能在发生一次自增长时分配的磁盘空间非常大。同样的：可以把新分配的所有的空闲区加入到FREE链表、也可以把一部分空闲区加入到FREE链表，等FREE链表不够用时，再把空闲的区对应的XDES Entry加入到FREE链表(InnoDB采用的是这种)
- Next Unused Segment ID: 表中的每个索引对应着2个段，每个段都有一个唯一的ID。当为某个表新建一个索引时，需要新建2个段，该字段表明当前表空间最大的段的ID的下一个ID。
- Space Flags: 表空间中与布尔类型相关的属性，或者只需要几个比特就能搞定的属性。
|标识名称|占用的空间大小(比特)|描述|
|:--:|:--:|:--:|
|POST_ANTELOPE|1|表示文件格式是否在ANTELOPE格式之后|
|ZIP_SSIZE|4|表示压缩页面大小|
|ATOMIC_BLOBS|1|表示是否自动把占用存储空间非常多的字段放到溢出页中|
|PAGE_SSIZE|4|页面大小|
|DATA_DIR|1|表示表空间是否是从数据目录中获取的|
|SHARED|1|是否为共享表空间|
|TEMPORARY|1|是否为临时表空间|
|ENCRYPTION|1|表空间是否加密|
|UNUSED|18|没有使用到的比特位|
- List Base Node for SET_INODES_FULL list、List Base Node for SET_INODES_FREE List: 每个段对应的INODE Entry结构会存放一个类型为INODE的页中。如果表空间中的段非常多时，则会有多个INODE Entry结构，此时一个页可能放不下，就需要多个INODE类型的页面，这些INODE类型的页面可以构成下面两种链表：
    1. SET_INODE_FULL链表: 在该链表中，INODE类型的页面都已经被INODE Entry结构填满，没有空闲空间存放额外的INODE Entry
    2. SET_INODE_FREE链表: 在该链表中，INODE类型的页面仍然可以存放INODE Entry结构

#### XDES Entry
没什么好说的了，一个XDES Entry结构的大小为40字节。XDES Entry 0对应着extent 0，XDES Entry 1对应着extent 1...因为每个区对应着的XDES Entry结构的地址都是固定的，因此可以很轻松的访问extent0对应着的XDEX Entry结构(页面偏移量为150字节)，extent 1对应的XDES Entry就是(150 + 40*1)，一次类推...

### XDES类型
与FSP_HDR类型的页面相比，除了没有File Space Header部分之外(也就是没有一些表空间的整体属性)，区域的部分都是一样的。XDES类型的页结构如下图所示：
![XDES类型的页结构示意图](XDES类型的页结构示意图.png)

### IBUF_BITMAP类型
这个类型的页中记录了一些Change Buffer的东西。向表中插入一条记录，其本质就是向每个索引对应的B+树中插入记录。该记录首先被插入到聚簇索引页面，然后在插入到每个二级索引页面。这些页面在表空间中随机分布，将会产生大量的随机I/O，严重影响性能，对于UPDATE和DELETE来说，也会带来许多随机I/O。所以需要引入Change Buffer结构来优化。在修改非唯一二级索引页面时，如果该页面尚未被加载到内存中(磁盘上)，那么该修改将先被暂时缓存到Change Buffer中，之后服务器空闲或者其他什么原因导致对应的页面从磁盘加载到内存时，再将修改合并到对应的页面。<font color="red">如果此时服务器宕机怎么办？</font>在很早的版本时，只会缓存INSERT操作对二级索引页面所做的修改，所以Change Buffer也叫Inser Buffer。

### INODE类型
每个索引定义了2个段，而且某些特殊功能由特殊的段，为了方便管理这些段，引入了一个INODE Entry的结构，这个结构记录了这个段的相关属性，INODE类型的页就是为了存储INODE Entry结构。INODE类型的页结构如下图所示：
![INODE类型的页结构示意图](INODE类型的页结构示意图.png)
|名称|中文名|占用空间大小(字节)|简单描述|
|:--:|:--:|:--:|:--:|
|File Header|文件头部|38|页的一些通用信息|
|List Node for INODE Page List|通用链表节点|12|存储上一个INODE页面和下一个INODE页面的指针|
|INODE Entry|段描述信息|16320|具体的INODE Entry结构|
|Empty Space|尚未使用空间|6|用于页结构的填充，没有啥实际意义|
|File Trailer|文件尾部|8|校验页是否完整|
- INODE Entry: 该结构的组成：主要包括对应的段内零散页面的地址以及附属于该段的FREE、NOT_FULL和FULL链表的基节点。每个INODE Entry占用192字节，一个页面可以存储85个这样的节点。
- List Node for INODE Page List: 如果一个表空间存在的段超过85个，那么一个INODE类型的页面不足以存储所有的段对应的INODE Entry结构，所以就需要额外的INODE类型的页来存储这些结构。为了方便管理这些INODE类型的页面，将其串连成2个不同的链表
    1. SET_INODE_FULL链表：在该链表中，INODE类型的页面中已经没有空间来存储INODE Entry结构了
    2. SET_INODE_FREE链表: 在该链表中，INODE类型的页面还有空闲来存储INODE Entry结构

这2个链表的基节点存储在FSP_HDR类型页面中的File Space Header中，就是说这2个链表的基节点是固定的，从而可以轻松访问这两个链表。以后每当新创建一个段(例如创建索引)时，都会创建一个与之对应的INODE Entry，存储INODE Entry的过程如下：
1. 查看SET_INODE_FREE链表是否为空，如果不为空，从该链表中获取一个节点(相当于获取一个由空闲空间的INODE类型页面)，然后把该INODE Entry结构存放到该页面中，当该页面无空闲空间时，就把该页面放到SET_INODE_FULL链表中。
2. 如果SET_INODE_FREE为空，则需要从表空间的FREE_FRAG链表中申请一个页面，并将该页面类型改为INODE类型，把该页面放到SET_INODE_FREE链表中，与此同时把INODE Entry存放到该页面中。

### Segment Header结构
一个索引产生2个段，分别是叶子节点段和非叶子节点段，每个段都会对应着一个INODE Entry结构。如何知道某个段对应那个INODE Entry呢？数据页(即INDEX类型的页)的Page Header部分中有2个属性：PAGE_BTR_SET_LEAF(B+树叶子结点段的头部信息，仅在B+树的根页中定义)和PAGE_BTR_SET_TOP(B+树非叶子节点段的头部信息，仅在B+树的根页中定义)，这2个属性都占用10个字节，它们其实对应一个Setment Header的结构，如下图所示：
![Segment_Header结构](Segment_Header结构.png)
|名称|占用空间大小(字节)|描述|
|:--:|:--:|:--:|
|Space ID of the INODE Entry|4|INODE Entry结构所在的表空间ID|
|Page Number of the INODE Entry|4|INODE Entry结构所在的页面页号|
|Byte Offset of the INODE Entry|2|INODE Entry结构在该页面中的偏移量|
PAGE_BTR_SET_LEAF记录着叶子节点段对应的INODE Entry结构的地址是哪个表空间哪个页面的哪个偏移量；PAGE_BTR_SET_TOP记录着非叶子节点段对应的INODE Entry结构的地址是哪个表空间中哪个页面的哪个偏移量。这样，索引和对应的段的关系就建立起来了。需要注意的是:<font color="red">因为一个索引对应两个段，所以只需要在索引的根页面中记录着两个结构即可</font>

## 系统表空间
系统表空间与独立表空间基本类似，由于整个MySQL进程只有一个系统表空间，系统表空间中需要记录一些与整个系统相关的信息，所以会比独立表空间多出一些用来记录这些信息的页面，它的表空间ID为0。
### 系统表空间的整体结构
![系统表空间结构](系统表空间结构.png)
系统表空间与独立表空间最大的不同之处就是在表空间开头有许多记录整个系统属性的页面，从上图可以看到系统表空间和独立表空间的前3个页面(页号分别为0,1,2，类型分别是FSP_HDR、IBUF_BITMAP、INODE)的类型是一致的，但是页号为3-7的页面时系统表空间特有的：
|页号|页面类型|英文描述|描述|
|:-:|:-:|:-:|:-:|
|3|SYS|Insert Buffer Header|存储Change Buffer的头部信息|
|4|INDEX|Insert Buffer Root|存储Change Buffer的根页面|
|5|TRX_SYS|Transction System|事务系统的相关信息|
|6|SYS|First Rollback Segment|第一个回滚段的信息|
|7|SYS|Data Dictionary Header|数据字典头部信息|

除了这几个记录系统属性的页面之外，系统表空间的extent1和extent2这两个区的128个页面成为Doublewrite Buffer(双写缓冲区)。

### InnoDB数据字典
我们使用INSERT语句向表中插入的那些记录称为用户数据，MySQL只是作为一个软件来为我们保管这些数据，提供方便的增删改查接口而已。但是每当像一个表中插入一条记录时，MySQL先要校验插入语句所随影的表是否存在，以及插入的列和表中的列是否符合。如果语法没有问题，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。所以MySQL除了保存插入的用户记录外，还需要保存许多额外的信息，如下：
- 某个表属于哪个表空间，表里面有多少列
- 表对应的每一个列的类型是什么
- 该表有多少个索引，每个索引对应哪几个字段，该索引对应的跟页面在哪个表空间的哪个页面
- 该表有哪些外键，外键对应哪个表的哪些列
- 某个表空间对应的文件系统上的文件路径是什么

上述信息并不是使用Insert语句插入的用户数据，实际上是为了更好的管理用户数据而不得已引入的一些额外的数据，这些数据也被称为元数据。InnoDB存储引擎特意定义了一系列的内部系统表来记录这些元数据：

|表明|描述|
|:--:|:--:|
|SYS_TABLES|整个InnoDB存储引擎中所有表的信息|
|SYS_COLUMNS|整个InnoDB存储引擎中所有列的信息|
|SYS_INDEXES|整个InnoDB存储引擎中所有索引的信息|
|SYS_FIELDS|整个InnoDB存储引擎中所有索引对应的列的信息|
|SYS_FOREIGN|整个InnoDB存储引擎中所有外键的信息|
|SYS_FOREIGN_COLS|整个InnoDB存储引擎中所有外键对应的列的信息|
|SYS_TABLESPACES|整个InnoDB存储引擎中所有表空间信息|
|SYS_DATAFILES|整个InnoDB存储引擎中所有表空间对应的文件系统的文件路径信息|
|SYS_VIRTUAL|整个InnoDB存储引擎中所有虚拟生成的列的信息|

这些系统表也被称为数据字典，他们都是以B+树的形式保存在系统表空间的某些页面中，其中SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS这四个表尤为重要，成为基本系统表

#### SYS_TABLES表
|列名|描述|
|:--:|:--:|
|NAME|表的名称|
|ID|在InnoDB存储引擎中，每个表都有的一个唯一的ID|
|N_COLS|该表拥有列的个数|
|TYPE|表的类型，记录了一些文件格式、行格式、压缩等信息|
|MIX_ID|已过时，忽略|
|MIX_LEN|表的一些额外属性|
|CLUSTER_ID|未使用，忽略|
|SPACE|该表所属表空间的ID|

SYS_TABLES表有两个索引，以NAME列为主键的聚簇索引，以ID列建立的二级索引

#### SYS_COLUMNS表
|列名|描述|
|:--:|:--:|
|TABLE_ID|该列所属表对应的ID|
|POS|该列在表中是第几列|
|NAME|该列的名称|
|MTYPE|主数据类型(main data type)，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE之类的东西|
|PRTYPE|精确数据类型(prccise type)，就是修改主数据类型的那堆东西，比如是否允许NULL值，是否允许负数|
|LEN|该列最多占用存储空间的字节数|
|PREC|该列的精度，默认值都是0|

SYS_COLUMNS表只有一个聚簇索引，即以(TABLE_ID, POS)列为主键的聚簇索引

#### SYS_INDEXES表
|列名|描述|
|:--:|:--:|
|TABLE_ID|该索引所属表对应的ID|
|ID|在InnoDB存储引擎中，每个索引都有的一个唯一的ID|
|NAME|该索引的名称|
|N_FIELDS|该索引包含的列的个数|
|TYPE|该索引的类型，比如聚簇索引，唯一二级索引，更改缓冲区的索引，全文索引，普通的二级索引|
|SPACE|该索引根页面所在的表空间ID|
|PAGE_NO|该索引根页面所在的页面号|
|MERGE_THRESHOLD|如果页面中的记录被删除到某个比例，就尝试把该页面和相邻页面合并，这个值就是这个比例|

SYS_INDEX表只有一个聚簇索引，即以(TABLE_ID, ID)列为主键的聚簇索引

#### SYS_FIELDS表
|列名|描述|
|:--:|:--:|
|INDEX_ID|该列所属索引的ID|
|POS|该列在索引列中是第几列|
|COL_NAME|该列的名称|

SYS_FIELDS表只有一个聚簇索引，即以(INDEX_ID, POS)列为主键的聚簇索引

#### Data Dictionary Header页面
只要有了上述四个基本系统表，也就意味着可以获取其他系统表以及用户定义的表的所有元数据。比如：SYS_TABLESSPACES系统表中存储了哪些表空间以及表空间对应的属性，就可以执行一下操作：
1. 根据表名到SYS_TABLES表中定位到具体的记录，从而获取到SYS_TABLESPACES表的TABLE_ID
2. 使用获取到的TABLE_ID到SYS_COLUMNS表中就可以获取到属于该表的所有列的信息
3. 使用获取到的TABLE_ID还可以到SYS_INDEXES表中获取所有的索引的信息。索引的信息中包括对应的INDEX_ID，还记录着该索引对应的B+树根页面是哪个表空间的哪个页面
4. 使用获取到的INDEX_ID就可以到SYS_FIELDS表中获取所有索引列的信息

上述四个系统基本表是表中之表，这四个表的元数据硬编码到代码中，然后用一个固定的页面来记录这四个表的聚簇索引和鸡儿索引对应的B+树的位置。就是页面就是页号为7的页面，类型为SYS，记录了Data Dictionary Header的信息，除了这4个表的5个索引的根页面信息外，这个页号为7的页面还记录了整个InnoDB存储引擎的一些全局属性。如下图所示：
![页号为7的页的组成部分及其描述](页号为7的页的组成部分及其描述.png)

|名称|占用空间大小(字节)|简单概述|
|:--:|:--:|:--:|
|File Header(文件头部)|38|页的一些通用信息|
|Data Dictionary Header(数据字典头部)|52|记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息|
|Unused|4|未使用|
|Segment Header(段头部)|10|记录本页面所在段随你应的INODE Entry位置信息|
|Empty Space(尚未使用的空间)|16272|用于页结构的填充，没啥实际意义|
|File Trailer(文件尾部)|8|校验页是否完整|

这个页面中也有Segment Header部分，这意味着这些有关数据字典的信息当成一个段来分配存储空间，称之为数据字典段。由于目前需要记录的数据字典信息非常少(可以看到Data Dictionary Header部分仅占用了52字节)，所以该段只有一个碎片页，也就是页号为7的这个页。下面详细说一下Data Dictionary Header部分的各个字段：
- Max Row ID: 如果不显示的为表定义主键，且表中也没有不允许存储NULL值的UNIQUE键，那么InnoDB存储引擎会默认生成一个名为row_id的列作为主键，因为其是主键，索引每条记录的row_id列的值不允许重复，原则上只要一个表中的row_id列不重复就可以了，也就是说表a和表b拥有一样的row_id列也没啥关系，不过MySQL只提供了Max Row ID字段，无论哪个拥有row_id列的表插入一条记录时，该记录的row_id列的值就是Max Row ID对应的值，然后再把Max Row ID对应的值加1，该字段是全局共享的。
- Max Table ID: 在InnoDB存储引擎中，所有的表都对应一个唯一的ID，每次新建一个表时，就会把该字段的值加1，然后将其作为该表的ID
- Max Index ID: 在InnoDB存储引擎中，所有的索引都对应一个唯一的ID，每次新建一个索引时，就会把该段的值加1，然后将其作为该索引的ID
- Max Space ID: 在InnoDB存储引擎中，所有的表空间都对应一个唯一的ID，每次新建一个表空间时，就会把该字段的值加1，然后将其作为该表空间的ID
- Mix ID Low(Unused): 这个字段没啥用
- Root of SYS_TABLES clust index: 表示SYS_TABLES表聚簇索引的根页面的页号
- Root of SYS_TABLES_IDS sec index: 表示SYS_TABLES表为ID列建立的二级索引的根页面的页号
- Root of SYS_COLUMNS clust index: 表示SYS_COLUMNS表聚簇索引的根页面的页号
- Root of SYS_INDEXES clust index: 表示SYS_INDEXES表局促讴吟的根页面的页号
- Root of SYS_FIELDS clust index: 表示SYS_FIELDS表聚簇索引的根页面的页号

#### information_schema系统数据库
用户不能直接访问InnoDB的这些内部系统表，除非直接去解析系统表空间对应的文件系统上的文件。不过MySQL提供了查看这些表的内容的方法，所以在系统数据库information_schema中提供了一些以INNODB_SYS开头的表：
- INNODB_SYS_DATAFILES
- INNODB_SYS_VIRTUAL
- INNODB_SYS_INDEXES
- INNODB_SYS_TABLES
- INNODB_SYS_FIELDS
- INNODB_SYS_TABLESPACES
- INNODB_SYS_FOREIGN_COLS
- INNODB_SYS_COLUMNS
- INNODB_SYS_FOREIGN
- INNODB_SYS_TABLESTATS

在information_schema数据库中，这些以INNODB_SYS开头的表并不是真正的内部系统表(内部系统表就是说以SYS开头的那些表)，而是在存储引擎启动时读取这些以SYS开头的系统表，然后填充到这些以INNODB_SYS开头的表中，以INNODB_SYS开头的表和以SYS开头的表中的字段并不完全一样，供用户查看已经足矣。