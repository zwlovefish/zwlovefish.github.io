---
title: MySQL的查询原理
date: 2023-06-13 00:47:10
tags: 面试,MySQL
categories: 面试
---
表结构：
![single_table表结构](single_table表结构.png)
# 访问方法
MySQL执行查询语句的方式称为访问方法或者访问类型。同一个查询语句可以使用多种不同访问方法来执行。
<!--more-->
## const
有时可以通过主键列来定位一条记录，如：
```sql
SELECT * FROM single_table WHERE id = 1;
```
MySQL会直接利用主键值在聚簇索引中定位对应的用户记录。与之类似，我们根据唯一索引来定位一条记录的速度也是贼快的，比如：
```sql
SELECT * FROM single_table WHERE key2=2;
```
这个查询执行可以分为两步：
1. 在uk_key对应的B+树索引中，根据key2列与常数的等值条件定位到一条二级索引记录。
2. 然后再根据该记录的id值到聚簇索引中获取到完整的用户记录。

通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像火箭一样快的，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为const。这种const访问方法只能在主键或者唯一二级索引列与一个常数进行等值比较时才有效。如果主键或者唯一二级索引的索引由多个列构成，则只有在索引列中的每一个列都与常数进行等值比较时，这个const访问方法才有效。

对于唯一二级索引列来说，在查询列为NULL值时，情况比较特殊，如下：
```sql
SELECT * FROM single_table WHERE key2 IS NULL
```
因为唯一二级索引列并不限制NULL值的数量，所以上述语名句可能访问到多条记录，也就是说上面这个语句不可以使用const访问方法来执行

## ref
将某个普通的二级索引列与常数进行比较，比如这样：
```sql
SELECT * FROM single_table WHERE key1='abc'
```
可以使用全表扫描的方式来执行。不过也可以使用idx_key1来执行，此时的扫描区间是['abc', 'abc']，这也是一个单点扫描区间。我们可以定位到key1='abc'条件的第一条记录，然后沿着记录所在的单向链表向后扫描，直到某条记录不符合key1='abc'条件为止。查询列表为*，因此需要执行回表操作，获取到所有的数据再发给客户端。

由于普通二级索引并不限制索引列值的唯一性，所以扫描区间['abc','abc']中的二级索引记录可能有多条，此时使用二级索引执行查询的代价就是取决于该扫描区间中的记录条数。如果该扫描区间中的记录较少，则回表操作的代价比较低。

搜索条件为二级索引列与常数进行等值比较，形成的扫描区间为单点扫描区间，采用二级索引来执行查询的访问方法称为ref。

采用二级索引来执行查询时，其实每获取一条二级索引记录，就会立刻对其执行回表操作，而不是将所有二级索引记录的主键值都收集起来后再统一执行回表操作。

有2种情况需要注意：
1. 在二级索引列允许存储NULL值时，无论是普通的二级索引，还是唯一二级索引，它们的索引列并不限制NULL值的数量，所以再执行包含"key IS NULL"形式的搜索条件的查询时，最多只能使用ref访问方法，而不能使用const访问方法
2. 对于索引列种包含多个列的二级索引来说，只要最左边连续的列是与常数进行等值比较，就可以采用ref访问方法，如果索引列中最左边连续的列不全部是等值比较的话，他的访问方法就不能称为ref了。

## ref_or_null
有时，我们不仅想找出某个二级索引列的值等于某个常数的记录，而且还想把该列中值为NULL的记录也找出来，例如：
```sql
SELECT * FROM single_table WHERE key1='abc' AND key1 IS NULL;
```

当使用二级索引而不是全表扫描的方式执行该查询时，对应的扫描区间就是[NULL, NULL]以及['abc','abc']，此时执行这种类型的查询所使用的访问方法就称为ref_or_null。

## range
某个查询如下：
```sql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) or (key2 >= 38 AND key2 <= 75);
```

如果使用idx_key2执行该查询，对应的扫描区间就是[1438,1438]、[6328,6328]以及[38.79]。

使用索引执行查询时，对应的扫描区间为若干个单点扫描区间或者范围扫描区间的访问方法称为range(仅包含一个单点扫描区间的访问方法不能称为range访问方法，扫描区间为[-无穷, +无穷]的访问方法也不能称为range访问方法)。

## index
某个查询如下：
```sql
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc'
```
由于key_part2并不是联合索引idx_key_part的索引列中最左边的列，所以无法形成合适的范围区间来减少需要扫描的记录数量，从而无法使用ref或者range访问方法来执行这个语句。但是这个查询符合下面这2个条件：
- 查询列表只有Key_part1,key_par2和key_part3这三列，而索引idx_key_part又恰好包含这3列
- 搜索条件只有Key_part2列，这个列也包含在索引idx_key_part中

我们可以直接遍历idx_key_part索引的所有二级索引记录，针对获取到的每一条二级索引记录，都判断key_part2='abc'条件是否成立。如果成立，就从中读取出key_part1，key_part2，key_part3这三列的值，这种使用idx_key_part索引执行上述查询的情况下，扫描区间是[-无穷，+无穷].

由于二级索引记录比聚簇索引记录小得多(聚簇索引记录要存储用户定义的所有列以及隐藏列，而二级索引记录只需要存放索引列和主键)，而且这个过程不用执行回表操作，所以直接扫描全部的二级索引记录要比直接扫描全部的聚簇索引记录的成本要小。

这种扫描全部二级索引记录的访问方法称为index访问方法。当通过全表扫描对使用InnoDB
存储引擎的表执行查询时，如果添加了“ORDER BY 主键”的雨具，该语句会被认为的定义为使用index访问方法。

## all
最直接的查询执行方式就是全表扫描，对于InnoDB表来说，也就是直接扫描全部的聚簇索引记录。这种使用全表扫描执行查询的访问方法称为all访问方法。

# 索引合并
MySQL在一般情况下只会为单个索引生成扫描区间，但还存在特殊情况，在这些特殊情况下，MySQL也可能为多个索引生成扫描区间，这种使用多个索引来完成一次查询的执行方法称为index merge(索引合并)。具体的索引合并方法有下面3种：

## Intersection索引合并
比如现在有下面这个查询：
```sql
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b'
```
可以使用以下三种方法：
1. 使用idx_key1索引执行该查询，此时对应的扫描区间就是['a', 'a']，对于获取到每条二级索引记录，根据它的id值执行回表操作后获取到完整的用户记录，再判断key3='b'条件是否成立。扫描区间['a', 'a']是一个单点扫描区间，也就是说位于该区间中的二级索引记录，其key1列的值都是'a'，这也就意味着这些二级索引记录其实是按照主键值排序的。
2. 使用idx_key3索引执行该查询，此时对应的扫描区间就是['b', 'b']，对于获取到的每条二级索引记录，根据它的id值执行回表操作后获取到完整的用户记录，再判断key1='a'条件是否成立。扫描区间['b', 'b']是一个单点扫描区间，也就是说位于该区间中的二级索引记录，其key3列的值都是'b'，这也就意味着这些二级索引记录其实是按照主键值排序的。
3. 同时使用idx_key1和idx_key3执行查询，也就是在idx_key1中扫描key1值在['a', 'a']区间中的二级索引记录，同时在idx_key3中扫描key3值在['b', 'b']区间中的二级索引记录，然后从两者的操作结果中找出id列相同的记录(即找出它们共有的id值)、然后再根据这些共有的id值执行回表操作(那些仅在单个扫描区间中包含的id值就不需要执行回表操作了)、

这里的方法3就是所谓的Intersection索引合并。Intersection索引合并指的就是对从不同索引中扫描到的记录的id值取交集，只为这些id值执行回表操作，如果使用Intersection索引合并的方式执行查询，并且每个使用到的索引都是二级索引的话，则要求从每个索引中获取到的二级索引记录都是主键值排序的。

为什么会要求从不同二级索引中获取到的二级索引记录都是按照主键排好序呢，有两方面的考虑：
1. 从两个有序集合中取交集比从两个无序集合中取交集要容易得多
2. 如果获取到id值是有序排列的，则在根据这些id值执行回表操作就不再是进行单纯的随机I/O，从而会提高效率。

假设idx_key1的扫描区间['a', 'a']中二级索引记录的id值是排好序的，且顺序为1，3，5，idx_key3的扫描区间['b', 'b']中二级索引记录的id值也是排好序的，且顺序为2，3，4，那么这个查询在使用Intersection索引合并来执行时，过程如下：
1. 先从idx_key1索引的扫描区间['a', 'a']中取出第一条二级索引记录，该记录的主键值为1，然后从idx_key3索引的扫描区间['b', 'b']中取出第一条二级索引记录，该记录的主键值为2，因为1<2, 所以直接把从idx_key1索引中取出的那条主键值为1的二级索引记录丢弃。
2. 接着继续从idx_key1索引的扫描区间['a', 'a']中取出下一条二级索引记录，该记录的主键值为3，步骤1中wwid_key3索引的扫描区间['b', 'b']中取出的二级索引记录的主键值为2。因为3>2，所以直接把步骤1中从idx_key3索引的扫描区间['b', 'b']中取出的主键值为2的那条记录丢弃。
3. 接着继续从id_key3索引的后扫描区间['b', 'b']中取出下一条二级索引记录，该记录的主键值为3。步骤2中从idx_key1索引的扫描区间['a', 'a']中取出的二级索引记录的主键值为3，因为3=3，也就意味着获取主键交集成功，然后根据该主键值执行回表操作，获取到完整的用户记录后将其发送给客户端。
4. 接着从idx_key1索引的扫描区间['a', 'a']中取出下一条二级索引记录，该记录的主键值为5，然后从idx_key3索引的扫描区间['b', 'b']中取出下一条二级索引记录，该记录的主键值为4，因为5>4，所以直接把从idx_key3索引的扫描区间['b', 'b']中取出的那条主键值为4的二级索引记录丢弃。
5. 接着从idx_key3索引的扫描区间['b', 'b']中取出下一条符合条件的二级索引记录，发现没有了，然后结束查询。

如果在使用某个二级索引执行查询时，从对应的扫描区间中读出的二级索引记录不是按照主键排序的，则不可以使用Intersection索引合并来执行查询。

## Union索引合并
比如如下查询：
```sql
SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b';
```
我们能仅使用idx_key1或者idx_key3执行上述查询吗？不行，假如使用idx_key1执行上述查询，那么对应的扫描区间就是(-无穷，+无穷)，而且需要针对获取到的每一条二级索引记录，都执行回表操作。在这种情况下是不能使用idx_key执行该查询的。

只能使用全表扫描的方式执行上述查询了吗？也不是，可以同时使用idx_key1和idx_key3来执行查询，也就是在idx_key1中扫描key1值位于['a', 'a']区间中的二级索引记录，同时在idx_key3中扫描位于['b', 'b']区间中的二级索引记录，然后根据二级索引记录的id值在两者的结果中进行去重，再根据去重后的id值执行回表操作，这样重复的id值只需要回表一次，这种方案就是所谓的Union索引合并。

如果使用Union索引合并的方式执行查询，并且每个使用到的索引都是二级索引的话，则要求从每个索引中获取到的二级索引记录都是按照主键值排序的。在上面的查询中，在idx_key1的['a', 'a']扫描区间中的二级索引记录都是按照主键值排序的，在idx_key3的['b', 'b']扫描区间中的二级索引记录也都是按照主键值排序的。这也是出于下面两个方面的考虑：
1. 从两个有序集合执行去重操作比从两个无序集合中执行去重操作容易一些
2. 如果获取到的id值是有序的话，那么在根据这些id值执行回表操作时就不是进行单纯的随机I/O(这些id值是有序的)，从而会提高效率。

如果在使用某个二级索引执行查询时，从对应的扫描中读取出的二级索引记录不是按照主键值排序的，则不可以使用Union索引合并的方式执行查询。另外，聚簇索引是比较特殊的存在，因为聚簇索引记录本身就是按照主键值进行排序的。

对于下面这个查询：
```sql
SELECT * FROM single_table WHERE (key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c') OR (key1 = 'a' AND key3 = 'b')
```

先通过idx_key1和idx_key3执行Intersection索引合并，这样可以找到与搜索引条件(key1='a' AND key3='b')匹配的记录，然后再通过idx_key_part执行Union索引合并即可。

## Sort-Union索引合并
Union索引合并的使用条件太苛刻，它必须保证从各个索引中扫描到的记录的主键值是有序的。比如下面这个查询就无法使用Union索引合并：
```sql
SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z'
```
不过key1<'a'和 key3 > 'z'这两个条件又特别，所以可以这样操作：
1. 先根据key1<'a'条件从idx_key1二级索引中获取二级索引记录，并将获取到的二级索引记录的主键值进行排序
2. 再根据key3>'z'条件从idx_key3二级索引中获取二级索引记录，并将获取到的二级索引记录的主键值进行排序
3. 因为上述两个二级索引主键值都是排好序的，所以剩下的操作就与Union索引合并方式一样了

先将从各个索引中扫描到的记录的主键进行排序，再按照执行Union索引合并的方式执行查询称为Sort-Union索引合并。

# 单表访问方法

# 连接的过程
两个表：
```sql
create table t1 (m1 int, n1 char(1))
create Table t2 (m2 int, n2 char(1))
```
连接查询中的过滤条件可以分为下面两种：
1. 涉及单表的条件：这种只涉及单表的过滤条件。比如t1.m1 > t1只针对t1表的过滤条件，t2.n2 < 'd'是只针对t2表的过滤条件。
2. 涉及两表的条件: 比如t1.m1=t2.m2、t1.n1>t2.n2等。

携带过滤条件的连接查询的大致执行过程，比如下面的这个查询语句：
```sql
SELECT * FROM t1,t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

在这个查询中，我们指明了3个过滤条件：
1. t1.m1 > 1
2. t1.m1 = t2.m2
3. t2.n1 < 'd'

这个连接查询的执行过程大致如下：
1. 首先确定第一个需要查询的表，这个表称为驱动表。这里假设使用t1作为驱动表，那么就需要到t1表中查找满足t1.m2>1的记录，表中数据量太少，没在表上建立二级索引，所以将查询t1表中所用的访问方法设定为all，也就是采用全表扫描的方式执行单表查询。可以看到t1表中符合t1.m1 > 1的记录有2条 
![查询过程1](查询过程1.png)
2. 步骤1中从驱动表每获取到一条记录，都需要到t2表中查找匹配的记录。所以t2表也可以称为被驱动表。步聚1从驱动表中得到了2条记录，也就意味着需要查询2次t2表。此时会使用涉及两个表的列的过滤条件t1.m1=t2.m2。对于从t1表中查询得到的第一条记录，也就是当t1.m2=2时，过滤条件t1.m2=t2.m2就相当于t2.m2=2.所以此时t2表就相当于有了t2.m2=2，t2.n2<'d'这两个过滤条件，然后到t2表中执行单表查询。对于从tx表中查询得到的第二条记录，也就是t1.m2=3时，过滤条件t1.m2=t2.m2就相当于t2.m2=3，所以此时t2表相当于有了t2.m2=3，t2.n2<'d'，然后到t2表中执行单表查询。