---
title: MySQL的查询原理
date: 2023-06-13 00:47:10
tags: 面试,MySQL
categories: 面试
---
表结构：
![single_table表结构](single_table表结构.png)
# 访问方法
MySQL执行查询语句的方式称为访问方法或者访问类型。同一个查询语句可以使用多种不同访问方法来执行。
<!--more-->
## const
有时可以通过主键列来定位一条记录，如：
```sql
SELECT * FROM single_table WHERE id = 1;
```
MySQL会直接利用主键值在聚簇索引中定位对应的用户记录。与之类似，我们根据唯一索引来定位一条记录的速度也是贼快的，比如：
```sql
SELECT * FROM single_table WHERE key2=2;
```
这个查询执行可以分为两步：
1. 在uk_key对应的B+树索引中，根据key2列与常数的等值条件定位到一条二级索引记录。
2. 然后再根据该记录的id值到聚簇索引中获取到完整的用户记录。

通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像火箭一样快的，所以他们把这种通过主键或者唯一二级索引列来定位一条记录的访问方法定义为const。这种const访问方法只能在主键或者唯一二级索引列与一个常数进行等值比较时才有效。如果主键或者唯一二级索引的索引由多个列构成，则只有在索引列中的每一个列都与常数进行等值比较时，这个const访问方法才有效。

对于唯一二级索引列来说，在查询列为NULL值时，情况比较特殊，如下：
```sql
SELECT * FROM single_table WHERE key2 IS NULL
```
因为唯一二级索引列并不限制NULL值的数量，所以上述语名句可能访问到多条记录，也就是说上面这个语句不可以使用const访问方法来执行

## ref
将某个普通的二级索引列与常数进行比较，比如这样：
```sql
SELECT * FROM single_table WHERE key1='abc'
```
可以使用全表扫描的方式来执行。不过也可以使用idx_key1来执行，此时的扫描区间是['abc', 'abc']，这也是一个单点扫描区间。我们可以定位到key1='abc'条件的第一条记录，然后沿着记录所在的单向链表向后扫描，直到某条记录不符合key1='abc'条件为止。查询列表为*，因此需要执行回表操作，获取到所有的数据再发给客户端。

由于普通二级索引并不限制索引列值的唯一性，所以扫描区间['abc','abc']中的二级索引记录可能有多条，此时使用二级索引执行查询的代价就是取决于该扫描区间中的记录条数。如果该扫描区间中的记录较少，则回表操作的代价比较低。

搜索条件为二级索引列与常数进行等值比较，形成的扫描区间为单点扫描区间，采用二级索引来执行查询的访问方法称为ref。

采用二级索引来执行查询时，其实每获取一条二级索引记录，就会立刻对其执行回表操作，而不是将所有二级索引记录的主键值都收集起来后再统一执行回表操作。

有2种情况需要注意：
1. 在二级索引列允许存储NULL值时，无论是普通的二级索引，还是唯一二级索引，它们的索引列并不限制NULL值的数量，所以再执行包含"key IS NULL"形式的搜索条件的查询时，最多只能使用ref访问方法，而不能使用const访问方法
2. 对于索引列种包含多个列的二级索引来说，只要最左边连续的列是与常数进行等值比较，就可以采用ref访问方法，如果索引列中最左边连续的列不全部是等值比较的话，他的访问方法就不能称为ref了。

## ref_or_null
有时，我们不仅想找出某个二级索引列的值等于某个常数的记录，而且还想把该列中值为NULL的记录也找出来，例如：
```sql
SELECT * FROM single_table WHERE key1='abc' AND key1 IS NULL;
```

当使用二级索引而不是全表扫描的方式执行该查询时，对应的扫描区间就是[NULL, NULL]以及['abc','abc']，此时执行这种类型的查询所使用的访问方法就称为ref_or_null。

## range
某个查询如下：
```sql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) or (key2 >= 38 AND key2 <= 75);
```

如果使用idx_key2执行该查询，对应的扫描区间就是[1438,1438]、[6328,6328]以及[38.79]。

使用索引执行查询时，对应的扫描区间为若干个单点扫描区间或者范围扫描区间的访问方法称为range(仅包含一个单点扫描区间的访问方法不能称为range访问方法，扫描区间为[-无穷, +无穷]的访问方法也不能称为range访问方法)。

## index
某个查询如下：
```sql
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc'
```
由于key_part2并不是联合索引idx_key_part的索引列中最左边的列，所以无法形成合适的范围区间来减少需要扫描的记录数量，从而无法使用ref或者range访问方法来执行这个语句。但是这个查询符合下面这2个条件：
- 查询列表只有Key_part1,key_par2和key_part3这三列，而索引idx_key_part又恰好包含这3列
- 搜索条件只有Key_part2列，这个列也包含在索引idx_key_part中

我们可以直接遍历idx_key_part索引的所有二级索引记录，针对获取到的每一条二级索引记录，都判断key_part2='abc'条件是否成立。如果成立，就从中读取出key_part1，key_part2，key_part3这三列的值，这种使用idx_key_part索引执行上述查询的情况下，扫描区间是[-无穷，+无穷].

由于二级索引记录比聚簇索引记录小得多(聚簇索引记录要存储用户定义的所有列以及隐藏列，而二级索引记录只需要存放索引列和主键)，而且这个过程不用执行回表操作，所以直接扫描全部的二级索引记录要比直接扫描全部的聚簇索引记录的成本要小。

这种扫描全部二级索引记录的访问方法称为index访问方法。当通过全表扫描对使用InnoDB
存储引擎的表执行查询时，如果添加了“ORDER BY 主键”的雨具，该语句会被认为的定义为使用index访问方法。

## all
最直接的查询执行方式就是全表扫描，对于InnoDB表来说，也就是直接扫描全部的聚簇索引记录。这种使用全表扫描执行查询的访问方法称为all访问方法。

# 索引合并
MySQL在一般情况下只会为单个索引生成扫描区间，但还存在特殊情况，在这些特殊情况下，MySQL也可能为多个索引生成扫描区间，这种使用多个索引来完成一次查询的执行方法称为index merge(索引合并)。具体的索引合并方法有下面3种：

## Intersection索引合并
比如现在有下面这个查询：
```sql
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b'
```
可以使用以下三种方法：
1. 使用idx_key1索引执行该查询，此时对应的扫描区间就是['a', 'a']，对于获取到每条二级索引记录，根据它的id值执行回表操作后获取到完整的用户记录，再判断key3='b'条件是否成立。扫描区间['a', 'a']是一个单点扫描区间，也就是说位于该区间中的二级索引记录，其key1列的值都是'a'，这也就意味着这些二级索引记录其实是按照主键值排序的。
2. 使用idx_key3索引执行该查询，此时对应的扫描区间就是['b', 'b']，对于获取到的每条二级索引记录，根据它的id值执行回表操作后获取到完整的用户记录，再判断key1='a'条件是否成立。扫描区间['b', 'b']是一个单点扫描区间，也就是说位于该区间中的二级索引记录，其key3列的值都是'b'，这也就意味着这些二级索引记录其实是按照主键值排序的。
3. 同时使用idx_key1和idx_key3执行查询，也就是在idx_key1中扫描key1值在['a', 'a']区间中的二级索引记录，同时在idx_key3中扫描key3值在['b', 'b']区间中的二级索引记录，然后从两者的操作结果中找出id列相同的记录(即找出它们共有的id值)、然后再根据这些共有的id值执行回表操作(那些仅在单个扫描区间中包含的id值就不需要执行回表操作了)、

这里的方法3就是所谓的Intersection索引合并。Intersection索引合并指的就是对从不同索引中扫描到的记录的id值取交集，只为这些id值执行回表操作，如果使用Intersection索引合并的方式执行查询，并且每个使用到的索引都是二级索引的话，则要求从每个索引中获取到的二级索引记录都是主键值排序的。

为什么会要求从不同二级索引中获取到的二级索引记录都是按照主键排好序呢，有两方面的考虑：
1. 从两个有序集合中取交集比从两个无序集合中取交集要容易得多
2. 如果获取到id值是有序排列的，则在根据这些id值执行回表操作就不再是进行单纯的随机I/O，从而会提高效率。

# 单表访问方法

# 连接的过程
两个表：
```sql
create table t1 (m1 int, n1 char(1))
create Table t2 (m2 int, n2 char(1))
```
连接查询中的过滤条件可以分为下面两种：
1. 涉及单表的条件：这种只涉及单表的过滤条件。比如t1.m1 > t1只针对t1表的过滤条件，t2.n2 < 'd'是只针对t2表的过滤条件。
2. 涉及两表的条件: 比如t1.m1=t2.m2、t1.n1>t2.n2等。

携带过滤条件的连接查询的大致执行过程，比如下面的这个查询语句：
```sql
SELECT * FROM t1,t2 WHERE t1.m1 = t2.m2 AND t2.n2 < 'd';
```

在这个查询中，我们指明了3个过滤条件：
1. t1.m1 > 1
2. t1.m1 = t2.m2
3. t2.n1 < 'd'
